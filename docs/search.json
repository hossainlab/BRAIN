[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "The BRAIN course is structured as a comprehensive training program with 16 modules covering fundamental to advanced topics in neurogenomics, single-cell analysis, and AI applications.\n\n\n\n\n\n\nNoteCourse Format\n\n\n\n\nDuration: To be announced\nFormat: online lectures\nPrerequisites: Basic knowledge of biology and programming is helpful but not required\nRequirements: Computer with internet connection, ability to install software"
  },
  {
    "objectID": "schedule.html#overview",
    "href": "schedule.html#overview",
    "title": "Course Schedule",
    "section": "",
    "text": "The BRAIN course is structured as a comprehensive training program with 16 modules covering fundamental to advanced topics in neurogenomics, single-cell analysis, and AI applications.\n\n\n\n\n\n\nNoteCourse Format\n\n\n\n\nDuration: To be announced\nFormat: online lectures\nPrerequisites: Basic knowledge of biology and programming is helpful but not required\nRequirements: Computer with internet connection, ability to install software"
  },
  {
    "objectID": "schedule.html#course-timeline",
    "href": "schedule.html#course-timeline",
    "title": "Course Schedule",
    "section": "Course Timeline",
    "text": "Course Timeline\nBelow is the tentative schedule for all course modules. Specific dates and session times will be announced.\n\n\n\n\n\n\n\n\n\nWeek\nModule\nTopic\nDuration\n\n\n\n\n1\nModule 1\nIntroduction to Neurogenomics\n2-3 hours\n\n\n1\nModule 2\nIntroduction to Single-Cell Technology\n2-3 hours\n\n\n2\nModule 3\nLinux Command Line Fundamentals\n3-4 hours\n\n\n2\nModule 4\nCellRanger Pipeline for Single-Cell Analysis\n2-3 hours\n\n\n3\nModule 5\nFundamentals of Python: Part 1\n3-4 hours\n\n\n3\nModule 6\nFundamentals of Python: Part 2\n3-4 hours\n\n\n4\nModule 7\nQuality Control\n2-3 hours\n\n\n4\nModule 8\nDimensionality Reduction\n2-3 hours\n\n\n5\nModule 9\nData Integration\n2-3 hours\n\n\n5\nModule 10\nClustering\n2-3 hours\n\n\n6\nModule 11\nDifferential Expression\n3-4 hours\n\n\n6\nModule 12\nCell Type Prediction\n2-3 hours\n\n\n7\nModule 13\nTrajectory Inference\n3-4 hours\n\n\n7\nModule 14\nSpatial Transcriptomics\n3-4 hours\n\n\n8\nModule 15\nDeep Learning in Single-Cell Genomics: Part 1\n3-4 hours\n\n\n8\nModule 16\nDeep Learning in Single-Cell Genomics: Part 2\n3-4 hours"
  },
  {
    "objectID": "schedule.html#module-organization",
    "href": "schedule.html#module-organization",
    "title": "Course Schedule",
    "section": "Module Organization",
    "text": "Module Organization\n\nPhase 1: Foundations (Weeks 1-3)\n\nFocus: Building foundational knowledge in neurogenomics, single-cell technology, and essential computational skills.\n\nIntroduction to neurogenomics and its importance in brain research\nUnderstanding single-cell RNA sequencing technology\nMastering Linux command-line tools\nLearning the CellRanger pipeline\nDeveloping Python programming skills\n\n\n\n\nPhase 2: Core Analysis Methods (Weeks 4-6)\n\nFocus: Learning essential single-cell data analysis techniques.\n\nQuality control and filtering of single-cell data\nDimensionality reduction and visualization\nData integration across datasets\nClustering and cell population identification\nDifferential expression analysis\nCell type annotation and prediction\n\n\n\n\nPhase 3: Advanced Topics (Weeks 7-8)\n\nFocus: Exploring advanced analysis methods and AI applications.\n\nTrajectory inference and pseudotime analysis\nSpatial transcriptomics analysis\nDeep learning methods for single-cell genomics\nNeural networks, autoencoders, and transformers\nIntegration of AI in neuroscience research"
  },
  {
    "objectID": "schedule.html#session-format",
    "href": "schedule.html#session-format",
    "title": "Course Schedule",
    "section": "Session Format",
    "text": "Session Format\nEach module typically includes:\n\nLecture Component (30-40%)\n\nTheoretical foundations\nMethod explanations\nReal-world applications\n\nHands-on Tutorial (50-60%)\n\nGuided coding exercises\nWorking with real datasets\nStep-by-step implementation\n\nDiscussion & Q&A (10-20%)\n\nQuestions and clarifications\nBest practices\nTroubleshooting"
  },
  {
    "objectID": "schedule.html#learning-resources",
    "href": "schedule.html#learning-resources",
    "title": "Course Schedule",
    "section": "Learning Resources",
    "text": "Learning Resources\n\n\n\n\n\n\nTipMaterials Provided\n\n\n\n\nLecture slides and notes\nCode notebooks and scripts\nPractice datasets\nReading materials and references\nRecording of sessions (when available)"
  },
  {
    "objectID": "schedule.html#prerequisites-by-module",
    "href": "schedule.html#prerequisites-by-module",
    "title": "Course Schedule",
    "section": "Prerequisites by Module",
    "text": "Prerequisites by Module\n\nNo Prerequisites Required\n\nModule 1: Introduction to Neurogenomics\nModule 2: Introduction to Single-Cell Technology\n\n\n\nLinux/Command Line Required\n\nModule 3 onwards (Linux basics taught in Module 3)\n\n\n\nPython Required\n\nModule 7 onwards (Python taught in Modules 5-6)\n\n\n\nPrevious Module Completion Recommended\n\nModules 7-16 build sequentially on previous modules"
  },
  {
    "objectID": "schedule.html#important-dates",
    "href": "schedule.html#important-dates",
    "title": "Course Schedule",
    "section": "Important Dates",
    "text": "Important Dates\n\n\n\n\n\n\nImportantKey Information\n\n\n\n\nRegistration Opens: TBA\nCourse Starts: TBA\nCourse Ends: TBA\nCertificate Distribution: After successful completion"
  },
  {
    "objectID": "schedule.html#time-commitment",
    "href": "schedule.html#time-commitment",
    "title": "Course Schedule",
    "section": "Time Commitment",
    "text": "Time Commitment\n\nLectures & Tutorials: 2-4 hours per module\nSelf-study & Practice: 2-3 hours per module (recommended)\nTotal Time: Approximately 60-80 hours"
  },
  {
    "objectID": "schedule.html#office-hours-support",
    "href": "schedule.html#office-hours-support",
    "title": "Course Schedule",
    "section": "Office Hours & Support",
    "text": "Office Hours & Support\n\nGetting Help\n\nOffice Hours: TBA\nDiscussion Forum: Available on course platform\nEmail Support: Contact information available on About page\nResponse Time: Within 24-48 hours"
  },
  {
    "objectID": "schedule.html#certificate-requirements",
    "href": "schedule.html#certificate-requirements",
    "title": "Course Schedule",
    "section": "Certificate Requirements",
    "text": "Certificate Requirements\nTo receive a course certificate, participants must:\n\nComplete all 16 modules\nSubmit required assignments/exercises (if applicable)\nParticipate in final project (if applicable)\nMeet minimum attendance requirements (if applicable)\n\n\n\n\n\n\n\n\nNoteStay Updated\n\n\n\nThis schedule is tentative and may be adjusted. Check back regularly for updates or subscribe to course notifications.\n\n\nView Course Modules About the Instructors"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html",
    "href": "modules/15-deep-learning-part1.html",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "",
    "text": "Deep learning offers powerful approaches for analyzing complex single-cell data, including dimensionality reduction, batch correction, and generative modeling.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand deep learning fundamentals\nApply autoencoders for dimensionality reduction\nUse variational autoencoders (VAEs)\nImplement scVI for batch correction\nTrain neural networks with PyTorch/TensorFlow"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#overview",
    "href": "modules/15-deep-learning-part1.html#overview",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "",
    "text": "Deep learning offers powerful approaches for analyzing complex single-cell data, including dimensionality reduction, batch correction, and generative modeling.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand deep learning fundamentals\nApply autoencoders for dimensionality reduction\nUse variational autoencoders (VAEs)\nImplement scVI for batch correction\nTrain neural networks with PyTorch/TensorFlow"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#why-deep-learning-for-single-cell",
    "href": "modules/15-deep-learning-part1.html#why-deep-learning-for-single-cell",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Why Deep Learning for Single-Cell?",
    "text": "Why Deep Learning for Single-Cell?\nAdvantages: - Handle high-dimensional data - Learn complex non-linear patterns - Integrate multiple data modalities - Scalable to millions of cells - Transfer learning from large datasets\nApplications: - Dimensionality reduction - Batch effect correction - Data integration - Imputation - Cell type prediction - Perturbation modeling"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#deep-learning-basics",
    "href": "modules/15-deep-learning-part1.html#deep-learning-basics",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Deep Learning Basics",
    "text": "Deep Learning Basics\n\nNeural Networks\nimport torch\nimport torch.nn as nn\n\n# Simple neural network\nclass SimpleNN(nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super().__init__()\n        self.fc1 = nn.Linear(input_dim, hidden_dim)\n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n\n# Create model\nmodel = SimpleNN(input_dim=2000, hidden_dim=128, output_dim=10)\n\n\nTraining Loop\nimport torch.optim as optim\n\n# Setup\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Training loop\nfor epoch in range(100):\n    # Forward pass\n    outputs = model(inputs)\n    loss = criterion(outputs, labels)\n\n    # Backward pass\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    if epoch % 10 == 0:\n        print(f'Epoch {epoch}, Loss: {loss.item():.4f}')"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#autoencoders-for-dimensionality-reduction",
    "href": "modules/15-deep-learning-part1.html#autoencoders-for-dimensionality-reduction",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Autoencoders for Dimensionality Reduction",
    "text": "Autoencoders for Dimensionality Reduction\n\nArchitecture\nclass Autoencoder(nn.Module):\n    def __init__(self, input_dim, latent_dim):\n        super().__init__()\n\n        # Encoder\n        self.encoder = nn.Sequential(\n            nn.Linear(input_dim, 1024),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(1024, 512),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(512, latent_dim)\n        )\n\n        # Decoder\n        self.decoder = nn.Sequential(\n            nn.Linear(latent_dim, 512),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(512, 1024),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(1024, input_dim)\n        )\n\n    def forward(self, x):\n        latent = self.encoder(x)\n        reconstructed = self.decoder(latent)\n        return reconstructed, latent\n\n# Create autoencoder\nae = Autoencoder(input_dim=2000, latent_dim=32)\n\n\nTraining Autoencoder\nfrom torch.utils.data import DataLoader, TensorDataset\n\n# Prepare data\nX_tensor = torch.FloatTensor(adata.X.toarray())\ndataset = TensorDataset(X_tensor)\ndataloader = DataLoader(dataset, batch_size=128, shuffle=True)\n\n# Loss function\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(ae.parameters(), lr=0.001)\n\n# Train\nfor epoch in range(50):\n    total_loss = 0\n\n    for batch in dataloader:\n        data = batch[0]\n\n        # Forward pass\n        reconstructed, latent = ae(data)\n        loss = criterion(reconstructed, data)\n\n        # Backward pass\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        total_loss += loss.item()\n\n    if epoch % 10 == 0:\n        print(f'Epoch {epoch}, Loss: {total_loss/len(dataloader):.4f}')\n\n# Extract latent representation\nae.eval()\nwith torch.no_grad():\n    _, latent = ae(X_tensor)\n    adata.obsm['X_ae'] = latent.numpy()\n\n# Visualize\nsc.pp.neighbors(adata, use_rep='X_ae')\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='cell_type')"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#variational-autoencoders-vae",
    "href": "modules/15-deep-learning-part1.html#variational-autoencoders-vae",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Variational Autoencoders (VAE)",
    "text": "Variational Autoencoders (VAE)\n\nArchitecture\nclass VAE(nn.Module):\n    def __init__(self, input_dim, latent_dim):\n        super().__init__()\n\n        # Encoder\n        self.encoder = nn.Sequential(\n            nn.Linear(input_dim, 512),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(512, 256),\n            nn.ReLU()\n        )\n\n        self.fc_mu = nn.Linear(256, latent_dim)\n        self.fc_logvar = nn.Linear(256, latent_dim)\n\n        # Decoder\n        self.decoder = nn.Sequential(\n            nn.Linear(latent_dim, 256),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(256, 512),\n            nn.ReLU(),\n            nn.Dropout(0.2),\n            nn.Linear(512, input_dim)\n        )\n\n    def encode(self, x):\n        h = self.encoder(x)\n        mu = self.fc_mu(h)\n        logvar = self.fc_logvar(h)\n        return mu, logvar\n\n    def reparameterize(self, mu, logvar):\n        std = torch.exp(0.5 * logvar)\n        eps = torch.randn_like(std)\n        return mu + eps * std\n\n    def decode(self, z):\n        return self.decoder(z)\n\n    def forward(self, x):\n        mu, logvar = self.encode(x)\n        z = self.reparameterize(mu, logvar)\n        reconstructed = self.decode(z)\n        return reconstructed, mu, logvar\n\n# VAE loss function\ndef vae_loss(reconstructed, original, mu, logvar):\n    reconstruction_loss = nn.MSELoss()(reconstructed, original)\n    kld_loss = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())\n    return reconstruction_loss + kld_loss"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#scvi-single-cell-variational-inference",
    "href": "modules/15-deep-learning-part1.html#scvi-single-cell-variational-inference",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "scVI: Single-Cell Variational Inference",
    "text": "scVI: Single-Cell Variational Inference\n\nInstallation\npip install scvi-tools\n\n\nBasic Usage\nimport scvi\n\n# Setup\nscvi.model.SCVI.setup_anndata(\n    adata,\n    layer=\"counts\",\n    batch_key=\"batch\",\n    labels_key=\"cell_type\"\n)\n\n# Create and train model\nmodel = scvi.model.SCVI(adata, n_latent=30)\nmodel.train()\n\n# Get latent representation\nlatent = model.get_latent_representation()\nadata.obsm['X_scVI'] = latent\n\n# Compute UMAP on scVI latent space\nsc.pp.neighbors(adata, use_rep='X_scVI')\nsc.tl.umap(adata)\n\n# Visualize\nsc.pl.umap(adata, color=['batch', 'cell_type'])\n\n\nscVI for Batch Correction\n# Train model\nmodel = scvi.model.SCVI(\n    adata,\n    n_layers=2,\n    n_latent=30,\n    gene_likelihood=\"nb\"\n)\n\nmodel.train(\n    max_epochs=400,\n    early_stopping=True\n)\n\n# Get batch-corrected expression\nadata.layers['scvi_normalized'] = model.get_normalized_expression()\n\n# Get latent representation\nadata.obsm['X_scVI'] = model.get_latent_representation()\n\n# Downstream analysis\nsc.pp.neighbors(adata, use_rep='X_scVI')\nsc.tl.leiden(adata)\nsc.tl.umap(adata)\n\nsc.pl.umap(adata, color=['batch', 'cell_type', 'leiden'])"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#scanvi-semi-supervised-learning",
    "href": "modules/15-deep-learning-part1.html#scanvi-semi-supervised-learning",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "scANVI: Semi-supervised Learning",
    "text": "scANVI: Semi-supervised Learning\n# Train scVI first\nvae = scvi.model.SCVI(adata, n_latent=30)\nvae.train()\n\n# Train scANVI with labels\nlvae = scvi.model.SCANVI.from_scvi_model(\n    vae,\n    unlabeled_category=\"Unknown\",\n    labels_key=\"cell_type\"\n)\n\nlvae.train(max_epochs=20)\n\n# Predict cell types\nadata.obs[\"predicted_cell_type\"] = lvae.predict()\n\n# Get latent representation\nadata.obsm['X_scANVI'] = lvae.get_latent_representation()\n\n# Visualize\nsc.pl.umap(adata, color=['cell_type', 'predicted_cell_type'])"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#totalvi-rna-protein-integration",
    "href": "modules/15-deep-learning-part1.html#totalvi-rna-protein-integration",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "totalVI: RNA + Protein Integration",
    "text": "totalVI: RNA + Protein Integration\n# For CITE-seq data\nscvi.model.TOTALVI.setup_anndata(\n    adata,\n    batch_key=\"batch\",\n    protein_expression_obsm_key=\"protein_expression\",\n    protein_names_uns_key=\"protein_names\"\n)\n\n# Train model\nmodel = scvi.model.TOTALVI(adata, n_latent=20)\nmodel.train()\n\n# Get joint latent representation\nlatent = model.get_latent_representation()\nadata.obsm['X_totalVI'] = latent\n\n# Get denoised protein expression\nprotein_normalized = model.get_normalized_expression(\n    n_samples=25,\n    return_mean=True,\n    transform_batch=\"batch1\"\n)"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#model-evaluation",
    "href": "modules/15-deep-learning-part1.html#model-evaluation",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Model Evaluation",
    "text": "Model Evaluation\n\nReconstruction Error\n# Evaluate reconstruction\nmodel.eval()\nwith torch.no_grad():\n    reconstructed, _ = model(X_test)\n    mse = nn.MSELoss()(reconstructed, X_test)\n    print(f\"Test MSE: {mse.item():.4f}\")\n\n\nClustering Metrics\nfrom sklearn.metrics import adjusted_rand_score, silhouette_score\n\n# Calculate metrics\nari = adjusted_rand_score(true_labels, predicted_labels)\nsilhouette = silhouette_score(latent_representation, predicted_labels)\n\nprint(f\"ARI: {ari:.3f}\")\nprint(f\"Silhouette: {silhouette:.3f}\")"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#best-practices",
    "href": "modules/15-deep-learning-part1.html#best-practices",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipDeep Learning Tips\n\n\n\n\nNormalize data appropriately\nUse appropriate loss functions\nMonitor training/validation loss\nUse early stopping\nTry different architectures\nUse GPU for large datasets\nCross-validate hyperparameters\nSave trained models"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#practical-exercise",
    "href": "modules/15-deep-learning-part1.html#practical-exercise",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad single-cell dataset with batch effects\nBuild and train a simple autoencoder\nVisualize latent representation\nTrain scVI model for batch correction\nCompare with traditional methods\nEvaluate integration quality\nUse scANVI for cell type prediction"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#key-takeaways",
    "href": "modules/15-deep-learning-part1.html#key-takeaways",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nDeep learning handles high-dimensional scRNA-seq data\nAutoencoders learn compact representations\nVAEs enable generative modeling\nscVI provides probabilistic framework\nBatch correction with deep learning is powerful\nMultiple specialized tools available"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#additional-resources",
    "href": "modules/15-deep-learning-part1.html#additional-resources",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nscvi-tools Documentation\nPyTorch Tutorials\nDeep Learning for Single-Cell Review"
  },
  {
    "objectID": "modules/15-deep-learning-part1.html#next-module",
    "href": "modules/15-deep-learning-part1.html#next-module",
    "title": "Module 15: Deep Learning in Single-Cell Genomics - Part 1",
    "section": "Next Module",
    "text": "Next Module\nContinue with advanced deep learning topics!\nContinue to Module 16: Deep Learning Part 2 →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/13-trajectory-inference.html",
    "href": "modules/13-trajectory-inference.html",
    "title": "Module 13: Trajectory Inference",
    "section": "",
    "text": "Trajectory inference reconstructs continuous cellular processes like differentiation, cell cycle, and response dynamics from snapshot single-cell data.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand pseudotime concepts\nApply trajectory inference methods\nInterpret trajectory results\nIdentify branch points and fate decisions\nAnalyze gene expression dynamics along trajectories"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#overview",
    "href": "modules/13-trajectory-inference.html#overview",
    "title": "Module 13: Trajectory Inference",
    "section": "",
    "text": "Trajectory inference reconstructs continuous cellular processes like differentiation, cell cycle, and response dynamics from snapshot single-cell data.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand pseudotime concepts\nApply trajectory inference methods\nInterpret trajectory results\nIdentify branch points and fate decisions\nAnalyze gene expression dynamics along trajectories"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#what-is-pseudotime",
    "href": "modules/13-trajectory-inference.html#what-is-pseudotime",
    "title": "Module 13: Trajectory Inference",
    "section": "What is Pseudotime?",
    "text": "What is Pseudotime?\nPseudotime: Computational ordering of cells along a continuous process\nApplications: - Neuronal differentiation - Cell cycle progression - Immune cell activation - Disease progression - Drug response dynamics"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#when-to-use-trajectory-analysis",
    "href": "modules/13-trajectory-inference.html#when-to-use-trajectory-analysis",
    "title": "Module 13: Trajectory Inference",
    "section": "When to Use Trajectory Analysis",
    "text": "When to Use Trajectory Analysis\n\nAppropriate for:\n\nDevelopment and differentiation\nCell state transitions\nTemporal processes\nContinuous biological processes\n\nNot appropriate for:\n\nDiscrete stable cell types\nNo expected transitions\nTechnical variation dominates"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#diffusion-pseudotime-dpt",
    "href": "modules/13-trajectory-inference.html#diffusion-pseudotime-dpt",
    "title": "Module 13: Trajectory Inference",
    "section": "Diffusion Pseudotime (DPT)",
    "text": "Diffusion Pseudotime (DPT)\n\nConcept\nModels cell-cell transitions as diffusion process\n\n\nImplementation\nimport scanpy as sc\n\n# Compute diffusion map\nsc.tl.diffmap(adata, n_comps=15)\n\n# Compute DPT\n# Set root cell (typically most undifferentiated)\nroot_cell = adata[adata.obs['cell_type'] == 'Progenitor'].obs_names[0]\nadata.uns['iroot'] = np.flatnonzero(adata.obs_names == root_cell)[0]\n\n# Run DPT\nsc.tl.dpt(adata, n_dcs=10)\n\n# Visualize\nsc.pl.diffmap(adata, color='dpt_pseudotime', cmap='viridis')\nsc.pl.umap(adata, color='dpt_pseudotime', cmap='viridis')"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#paga-partition-based-graph-abstraction",
    "href": "modules/13-trajectory-inference.html#paga-partition-based-graph-abstraction",
    "title": "Module 13: Trajectory Inference",
    "section": "PAGA (Partition-based Graph Abstraction)",
    "text": "PAGA (Partition-based Graph Abstraction)\n\nConcept\nBuilds abstracted graph connecting cell clusters\n\n\nImplementation\n# Compute PAGA\nsc.tl.paga(adata, groups='leiden')\n\n# Visualize PAGA graph\nsc.pl.paga(adata, color=['leiden', 'dpt_pseudotime'])\n\n# PAGA-initialized UMAP\nsc.tl.umap(adata, init_pos='paga')\nsc.pl.umap(adata, color=['leiden', 'dpt_pseudotime'])"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#slingshot",
    "href": "modules/13-trajectory-inference.html#slingshot",
    "title": "Module 13: Trajectory Inference",
    "section": "Slingshot",
    "text": "Slingshot\n# Via rpy2 interface\nimport rpy2.robjects as ro\n\nro.r('''\nlibrary(slingshot)\nlibrary(SingleCellExperiment)\n\n# Run Slingshot\nsce &lt;- slingshot(sce,\n                 clusterLabels = 'cell_type',\n                 reducedDim = 'UMAP',\n                 start.clus = \"Progenitor\")\n\n# Get pseudotime\npseudotime &lt;- slingPseudotime(sce)\n''')"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#monocle-3",
    "href": "modules/13-trajectory-inference.html#monocle-3",
    "title": "Module 13: Trajectory Inference",
    "section": "Monocle 3",
    "text": "Monocle 3\n# Via rpy2\nro.r('''\nlibrary(monocle3)\n\n# Create Monocle object\ncds &lt;- new_cell_data_set(\n    expression_data = counts,\n    cell_metadata = metadata,\n    gene_metadata = genes\n)\n\n# Preprocess\ncds &lt;- preprocess_cds(cds)\ncds &lt;- reduce_dimension(cds)\n\n# Learn trajectory\ncds &lt;- cluster_cells(cds)\ncds &lt;- learn_graph(cds)\n\n# Order cells\ncds &lt;- order_cells(cds)\n\n# Plot\nplot_cells(cds,\n           color_cells_by = \"pseudotime\",\n           label_cell_groups = FALSE)\n''')"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#palantir",
    "href": "modules/13-trajectory-inference.html#palantir",
    "title": "Module 13: Trajectory Inference",
    "section": "Palantir",
    "text": "Palantir\nimport palantir\n\n# Run Palantir\npr_res = palantir.core.run_palantir(\n    adata,\n    early_cell='cell_id',  # Root cell\n    num_waypoints=500\n)\n\n# Add results to adata\nadata.obs['palantir_pseudotime'] = pr_res.pseudotime\nadata.obsm['palantir_fate_probs'] = pr_res.branch_probs\n\n# Visualize\npalantir.plot.plot_palantir_results(pr_res, adata)"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#cellrank",
    "href": "modules/13-trajectory-inference.html#cellrank",
    "title": "Module 13: Trajectory Inference",
    "section": "CellRank",
    "text": "CellRank\nimport cellrank as cr\n\n# Compute RNA velocity (if available)\nimport scvelo as scv\nscv.tl.velocity(adata, mode='stochastic')\nscv.tl.velocity_graph(adata)\n\n# Initialize CellRank\nvk = cr.tl.kernels.VelocityKernel(adata)\nvk.compute_transition_matrix()\n\n# Compute initial and terminal states\ng = cr.tl.estimators.GPCCA(vk)\ng.compute_macrostates(n_states=5)\ng.compute_terminal_states()\n\n# Compute absorption probabilities\ng.compute_absorption_probabilities()\n\n# Plot\ng.plot_macrostates(which='terminal')"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#analyzing-gene-expression-dynamics",
    "href": "modules/13-trajectory-inference.html#analyzing-gene-expression-dynamics",
    "title": "Module 13: Trajectory Inference",
    "section": "Analyzing Gene Expression Dynamics",
    "text": "Analyzing Gene Expression Dynamics\n\nGenes Along Pseudotime\n# Smooth gene expression along pseudotime\nsc.pl.scatter(adata, x='dpt_pseudotime', y='BDNF', color='cell_type')\n\n# Multiple genes\ngenes = ['SOX2', 'DCX', 'RBFOX3', 'SYN1']\nfor gene in genes:\n    sc.pl.scatter(adata, x='dpt_pseudotime', y=gene)\n\n\nHeatmap of Dynamic Genes\n# Find genes that vary along pseudotime\n# Correlation with pseudotime\nimport pandas as pd\nfrom scipy.stats import spearmanr\n\npseudotime_corrs = []\nfor gene in adata.var_names:\n    corr, pval = spearmanr(\n        adata.obs['dpt_pseudotime'],\n        adata[:, gene].X.toarray().flatten()\n    )\n    pseudotime_corrs.append((gene, corr, pval))\n\n# Convert to DataFrame\ncorr_df = pd.DataFrame(\n    pseudotime_corrs,\n    columns=['gene', 'correlation', 'pvalue']\n)\n\n# Filter significant genes\ndynamic_genes = corr_df[\n    (corr_df['pvalue'] &lt; 0.01) &\n    (corr_df['correlation'].abs() &gt; 0.3)\n].sort_values('correlation')\n\n# Heatmap\ntop_genes = dynamic_genes['gene'].values[:50]\n\n# Order cells by pseudotime\nadata_ordered = adata[adata.obs['dpt_pseudotime'].argsort()]\n\nsc.pl.heatmap(\n    adata_ordered,\n    top_genes,\n    groupby='cell_type',\n    swap_axes=True,\n    cmap='RdBu_r',\n    standard_scale='var'\n)"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#branch-point-analysis",
    "href": "modules/13-trajectory-inference.html#branch-point-analysis",
    "title": "Module 13: Trajectory Inference",
    "section": "Branch Point Analysis",
    "text": "Branch Point Analysis\n\nIdentifying Branches\n# With PAGA\nsc.tl.paga(adata, groups='leiden')\n\n# Identify branch points\n# Look for nodes with &gt;2 connections\npaga_graph = adata.uns['paga']['connectivities']\n\n# Find branch points (clusters with multiple downstream fates)\n\n\nBranch-Specific Genes\n# Compare cells in different branches\nbranch1_cells = adata[adata.obs['branch'] == 'Branch1']\nbranch2_cells = adata[adata.obs['branch'] == 'Branch2']\n\n# Find branch-specific DE genes\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='branch',\n    groups=['Branch1'],\n    reference='Branch2',\n    method='wilcoxon'\n)\n\n# Visualize\nsc.pl.rank_genes_groups(adata, n_genes=20)"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#velocity-analysis",
    "href": "modules/13-trajectory-inference.html#velocity-analysis",
    "title": "Module 13: Trajectory Inference",
    "section": "Velocity Analysis",
    "text": "Velocity Analysis\n\nRNA Velocity\nimport scvelo as scv\n\n# Load spliced/unspliced counts\nadata = scv.read('data.loom', cache=True)\n\n# Preprocess\nscv.pp.filter_and_normalize(adata)\nscv.pp.moments(adata)\n\n# Compute velocity\nscv.tl.velocity(adata, mode='stochastic')\nscv.tl.velocity_graph(adata)\n\n# Visualize\nscv.pl.velocity_embedding_stream(adata, basis='umap')\nscv.pl.velocity_embedding(adata, basis='umap', arrow_length=3)\n\n\nVelocity Pseudotime\n# Infer pseudotime from velocity\nscv.tl.velocity_pseudotime(adata)\n\n# Visualize\nscv.pl.scatter(adata, color='velocity_pseudotime', cmap='gnuplot')"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#validation-and-interpretation",
    "href": "modules/13-trajectory-inference.html#validation-and-interpretation",
    "title": "Module 13: Trajectory Inference",
    "section": "Validation and Interpretation",
    "text": "Validation and Interpretation\n\nQuality Checks\n\n\n\n\n\n\nTipValidation Steps\n\n\n\n\nBiological coherence: Does trajectory match known biology?\nMarker gene expression: Progressive changes expected?\nMultiple methods: Do different methods agree?\nRobustness: Stable across parameters?\nOrthogonal validation: Confirm with time-series data\n\n\n\n\n\nStatistical Tests\n# Test for monotonic trends\nfrom scipy.stats import spearmanr\n\nfor gene in marker_genes:\n    corr, pval = spearmanr(\n        adata.obs['dpt_pseudotime'],\n        adata[:, gene].X.toarray()\n    )\n    print(f\"{gene}: r={corr:.3f}, p={pval:.3e}\")"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#common-pitfalls",
    "href": "modules/13-trajectory-inference.html#common-pitfalls",
    "title": "Module 13: Trajectory Inference",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nForcing trajectory on discrete cell types\nIncorrect root cell selection\nOver-interpreting branching\nIgnoring batch effects\nInsufficient cell numbers\nTechnical variation masking biology"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#best-practices",
    "href": "modules/13-trajectory-inference.html#best-practices",
    "title": "Module 13: Trajectory Inference",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nImportantTrajectory Analysis Tips\n\n\n\n\nValidate with known markers\nTry multiple methods\nCheck parameter sensitivity\nUse biological knowledge to set root\nConsider experimental time points\nValidate key findings experimentally\nReport method details and parameters"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#practical-exercise",
    "href": "modules/13-trajectory-inference.html#practical-exercise",
    "title": "Module 13: Trajectory Inference",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad developmental or differentiation dataset\nIdentify appropriate root cell\nCompute diffusion pseudotime\nRun PAGA to identify trajectories\nFind genes correlated with pseudotime\nCreate heatmap of dynamic genes\nIdentify branch points\nValidate with known developmental markers"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#key-takeaways",
    "href": "modules/13-trajectory-inference.html#key-takeaways",
    "title": "Module 13: Trajectory Inference",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nPseudotime orders cells along continuous processes\nMultiple methods available, no universal best\nRoot cell selection is critical\nValidate with biological knowledge\nGene expression dynamics reveal regulatory programs\nRNA velocity adds directionality information"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#additional-resources",
    "href": "modules/13-trajectory-inference.html#additional-resources",
    "title": "Module 13: Trajectory Inference",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nTrajectory Inference Benchmarking\nscVelo Documentation\nCellRank Tutorial\nMonocle 3"
  },
  {
    "objectID": "modules/13-trajectory-inference.html#next-module",
    "href": "modules/13-trajectory-inference.html#next-module",
    "title": "Module 13: Trajectory Inference",
    "section": "Next Module",
    "text": "Next Module\nExplore spatial organization with spatial transcriptomics!\nContinue to Module 14: Spatial Transcriptomics →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/11-differential-expression.html",
    "href": "modules/11-differential-expression.html",
    "title": "Module 11: Differential Expression Analysis",
    "section": "",
    "text": "Differential expression analysis identifies genes with significant expression differences between cell populations or conditions.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand DE analysis in single-cell context\nApply statistical tests for DE\nHandle confounding factors\nInterpret and visualize DE results\nPerform functional enrichment analysis"
  },
  {
    "objectID": "modules/11-differential-expression.html#overview",
    "href": "modules/11-differential-expression.html#overview",
    "title": "Module 11: Differential Expression Analysis",
    "section": "",
    "text": "Differential expression analysis identifies genes with significant expression differences between cell populations or conditions.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand DE analysis in single-cell context\nApply statistical tests for DE\nHandle confounding factors\nInterpret and visualize DE results\nPerform functional enrichment analysis"
  },
  {
    "objectID": "modules/11-differential-expression.html#types-of-de-comparisons",
    "href": "modules/11-differential-expression.html#types-of-de-comparisons",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Types of DE Comparisons",
    "text": "Types of DE Comparisons\n\nBetween cell types: Marker genes\nBetween conditions: Disease vs control\nBetween time points: Temporal dynamics\nWithin cell type: Subpopulation differences"
  },
  {
    "objectID": "modules/11-differential-expression.html#differential-expression-methods",
    "href": "modules/11-differential-expression.html#differential-expression-methods",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Differential Expression Methods",
    "text": "Differential Expression Methods\n\nWilcoxon Rank-Sum Test\nimport scanpy as sc\n\n# Find markers for all clusters\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='cell_type',\n    method='wilcoxon',\n    key_added='wilcoxon'\n)\n\n# Visualize\nsc.pl.rank_genes_groups(adata, n_genes=20, key='wilcoxon')\n\n\nt-test\n# t-test (faster, assumes normality)\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='cell_type',\n    method='t-test',\n    key_added='ttest'\n)\n\n\nLogistic Regression\n# Logistic regression\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='cell_type',\n    method='logreg',\n    key_added='logreg'\n)"
  },
  {
    "objectID": "modules/11-differential-expression.html#one-vs-rest-comparisons",
    "href": "modules/11-differential-expression.html#one-vs-rest-comparisons",
    "title": "Module 11: Differential Expression Analysis",
    "section": "One vs Rest Comparisons",
    "text": "One vs Rest Comparisons\n# Each cluster vs all others\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='leiden',\n    method='wilcoxon',\n    key_added='rank_genes_groups'\n)\n\n# View results\nresult = adata.uns['rank_genes_groups']\ngroups = result['names'].dtype.names\n\n# Extract for specific cluster\ncluster_0_genes = sc.get.rank_genes_groups_df(adata, group='0')\nprint(cluster_0_genes.head(20))"
  },
  {
    "objectID": "modules/11-differential-expression.html#pairwise-comparisons",
    "href": "modules/11-differential-expression.html#pairwise-comparisons",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Pairwise Comparisons",
    "text": "Pairwise Comparisons\n# Compare specific groups\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='cell_type',\n    groups=['Neurons'],\n    reference='Astrocytes',\n    method='wilcoxon',\n    key_added='neurons_vs_astrocytes'\n)"
  },
  {
    "objectID": "modules/11-differential-expression.html#filtering-de-results",
    "href": "modules/11-differential-expression.html#filtering-de-results",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Filtering DE Results",
    "text": "Filtering DE Results\n# Get results DataFrame\nde_results = sc.get.rank_genes_groups_df(adata, group='Neurons')\n\n# Filter by significance and fold change\nsignificant = de_results[\n    (de_results['pvals_adj'] &lt; 0.05) &\n    (de_results['logfoldchanges'].abs() &gt; 1)\n]\n\n# Top upregulated genes\ntop_up = significant[significant['logfoldchanges'] &gt; 0].head(20)\n\n# Top downregulated genes\ntop_down = significant[significant['logfoldchanges'] &lt; 0].head(20)"
  },
  {
    "objectID": "modules/11-differential-expression.html#visualizing-de-results",
    "href": "modules/11-differential-expression.html#visualizing-de-results",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Visualizing DE Results",
    "text": "Visualizing DE Results\n\nVolcano Plot\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create volcano plot\nde_df = sc.get.rank_genes_groups_df(adata, group='Neurons')\n\nplt.figure(figsize=(10, 6))\nplt.scatter(\n    de_df['logfoldchanges'],\n    -np.log10(de_df['pvals_adj']),\n    alpha=0.5\n)\n\n# Highlight significant genes\nsig = de_df[de_df['pvals_adj'] &lt; 0.05]\nplt.scatter(\n    sig['logfoldchanges'],\n    -np.log10(sig['pvals_adj']),\n    c='red',\n    alpha=0.7\n)\n\nplt.xlabel('Log2 Fold Change')\nplt.ylabel('-Log10 Adjusted P-value')\nplt.title('Volcano Plot: Neurons vs Rest')\nplt.axhline(-np.log10(0.05), color='gray', linestyle='--')\nplt.axvline(1, color='gray', linestyle='--')\nplt.axvline(-1, color='gray', linestyle='--')\nplt.show()\n\n\nMA Plot\n# Mean-difference plot\nplt.figure(figsize=(10, 6))\nplt.scatter(\n    de_df['mean_expression'],\n    de_df['logfoldchanges'],\n    alpha=0.5\n)\nplt.xlabel('Mean Expression')\nplt.ylabel('Log2 Fold Change')\nplt.title('MA Plot')\nplt.axhline(0, color='gray', linestyle='--')\nplt.show()\n\n\nHeatmap\n# Heatmap of top DE genes\ntop_genes = de_df.nsmallest(50, 'pvals_adj')['names'].values\n\nsc.pl.heatmap(\n    adata,\n    top_genes,\n    groupby='cell_type',\n    cmap='RdBu_r',\n    dendrogram=True,\n    standard_scale='var'\n)\n\n\nDot Plot\n# Dot plot of marker genes\nmarker_genes = de_df.nsmallest(10, 'pvals_adj')['names'].values\n\nsc.pl.dotplot(\n    adata,\n    marker_genes,\n    groupby='cell_type',\n    dendrogram=True\n)\n\n\nViolin Plot\n# Violin plot of top markers\nsc.pl.violin(\n    adata,\n    marker_genes[:5],\n    groupby='cell_type',\n    rotation=45\n)"
  },
  {
    "objectID": "modules/11-differential-expression.html#condition-specific-de",
    "href": "modules/11-differential-expression.html#condition-specific-de",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Condition-Specific DE",
    "text": "Condition-Specific DE\n# Compare disease vs control within cell type\nneurons = adata[adata.obs['cell_type'] == 'Neurons'].copy()\n\nsc.tl.rank_genes_groups(\n    neurons,\n    groupby='condition',\n    groups=['disease'],\n    reference='control',\n    method='wilcoxon',\n    key_added='disease_vs_control'\n)\n\n# Extract results\nde_disease = sc.get.rank_genes_groups_df(neurons, group='disease')"
  },
  {
    "objectID": "modules/11-differential-expression.html#pseudobulk-de-analysis",
    "href": "modules/11-differential-expression.html#pseudobulk-de-analysis",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Pseudobulk DE Analysis",
    "text": "Pseudobulk DE Analysis\nimport pandas as pd\n\n# Aggregate counts by sample\ndef pseudobulk(adata, groupby, sample_key):\n    \"\"\"Create pseudobulk samples.\"\"\"\n    pseudobulk_data = {}\n\n    for group in adata.obs[groupby].unique():\n        for sample in adata.obs[sample_key].unique():\n            mask = (adata.obs[groupby] == group) & (adata.obs[sample_key] == sample)\n            if mask.sum() &gt; 10:  # Minimum cells\n                counts = adata[mask].X.sum(axis=0)\n                pseudobulk_data[f\"{group}_{sample}\"] = counts.A1\n\n    return pd.DataFrame(pseudobulk_data, index=adata.var_names)\n\n# Create pseudobulk\npb_counts = pseudobulk(adata, groupby='cell_type', sample_key='sample')\n\n# Analyze with edgeR or DESeq2 (in R)"
  },
  {
    "objectID": "modules/11-differential-expression.html#using-deseq2-via-rpy2",
    "href": "modules/11-differential-expression.html#using-deseq2-via-rpy2",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Using DESeq2 (via rpy2)",
    "text": "Using DESeq2 (via rpy2)\n# Import DESeq2 through rpy2\nimport rpy2.robjects as ro\nfrom rpy2.robjects import pandas2ri\npandas2ri.activate()\n\n# Run DESeq2\nro.r('''\nlibrary(DESeq2)\n\nrun_deseq2 &lt;- function(counts, coldata) {\n    dds &lt;- DESeqDataSetFromMatrix(\n        countData = counts,\n        colData = coldata,\n        design = ~ condition\n    )\n    dds &lt;- DESeq(dds)\n    results(dds)\n}\n''')"
  },
  {
    "objectID": "modules/11-differential-expression.html#handling-covariates",
    "href": "modules/11-differential-expression.html#handling-covariates",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Handling Covariates",
    "text": "Handling Covariates\n# Control for batch effects\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='cell_type',\n    method='logreg',\n    use_raw=False\n)\n\n# Use regression to account for confounders\n# (batch, nCount, nFeature, etc.)"
  },
  {
    "objectID": "modules/11-differential-expression.html#gene-set-enrichment",
    "href": "modules/11-differential-expression.html#gene-set-enrichment",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Gene Set Enrichment",
    "text": "Gene Set Enrichment\n\nPathway Enrichment\nimport gseapy as gp\n\n# Get gene list\ngene_list = de_results.nsmallest(100, 'pvals_adj')['names'].tolist()\n\n# Run enrichment\nenr = gp.enrichr(\n    gene_list=gene_list,\n    gene_sets=['GO_Biological_Process_2021',\n               'KEGG_2021_Human',\n               'WikiPathways_2021_Human'],\n    organism='Human',\n    outdir='enrichment_results'\n)\n\n# View results\nprint(enr.results.head(10))\n\n# Plot\ngp.barplot(enr.results, title='GO Enrichment')\n\n\nGene Ontology\nfrom gprofiler import GProfiler\n\ngp = GProfiler(return_dataframe=True)\n\nresult = gp.profile(\n    organism='hsapiens',\n    query=gene_list,\n    sources=['GO:BP', 'KEGG', 'REAC']\n)\n\nprint(result.head())"
  },
  {
    "objectID": "modules/11-differential-expression.html#best-practices",
    "href": "modules/11-differential-expression.html#best-practices",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipDE Analysis Tips\n\n\n\n\nUse appropriate statistical tests\nApply multiple testing correction\nSet meaningful fold-change thresholds\nInclude biological replicates\nConsider pseudobulk for condition comparisons\nValidate key genes with qPCR/IF\nPerform functional enrichment\nReport both p-values and effect sizes"
  },
  {
    "objectID": "modules/11-differential-expression.html#common-pitfalls",
    "href": "modules/11-differential-expression.html#common-pitfalls",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nNot accounting for batch effects\nComparing conditions without replicates\nOver-interpreting small fold changes\nIgnoring multiple testing correction\nUsing single-cell for group comparisons (use pseudobulk)"
  },
  {
    "objectID": "modules/11-differential-expression.html#practical-exercise",
    "href": "modules/11-differential-expression.html#practical-exercise",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nIdentify marker genes for each cell type\nCompare two specific cell populations\nCreate volcano and MA plots\nFilter for significant genes\nVisualize top markers with heatmap\nPerform pathway enrichment\nInterpret biological meaning"
  },
  {
    "objectID": "modules/11-differential-expression.html#key-takeaways",
    "href": "modules/11-differential-expression.html#key-takeaways",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMultiple statistical methods available\nWilcoxon is robust and widely used\nAccount for multiple testing\nUse pseudobulk for condition comparisons\nVisualize results comprehensively\nFunctional enrichment adds biological context"
  },
  {
    "objectID": "modules/11-differential-expression.html#additional-resources",
    "href": "modules/11-differential-expression.html#additional-resources",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nDifferential Expression Best Practices\nPseudobulk Methods\nScanpy DE Tutorial"
  },
  {
    "objectID": "modules/11-differential-expression.html#next-module",
    "href": "modules/11-differential-expression.html#next-module",
    "title": "Module 11: Differential Expression Analysis",
    "section": "Next Module",
    "text": "Next Module\nLearn to annotate cell types automatically!\nContinue to Module 12: Cell Type Prediction →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/09-data-integration.html",
    "href": "modules/09-data-integration.html",
    "title": "Module 9: Data Integration",
    "section": "",
    "text": "Integrating multiple single-cell datasets enables meta-analyses, removes batch effects, and increases statistical power.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand batch effects in single-cell data\nApply integration methods (Harmony, Scanorama, etc.)\nEvaluate integration quality\nChoose appropriate integration strategies"
  },
  {
    "objectID": "modules/09-data-integration.html#overview",
    "href": "modules/09-data-integration.html#overview",
    "title": "Module 9: Data Integration",
    "section": "",
    "text": "Integrating multiple single-cell datasets enables meta-analyses, removes batch effects, and increases statistical power.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand batch effects in single-cell data\nApply integration methods (Harmony, Scanorama, etc.)\nEvaluate integration quality\nChoose appropriate integration strategies"
  },
  {
    "objectID": "modules/09-data-integration.html#why-data-integration",
    "href": "modules/09-data-integration.html#why-data-integration",
    "title": "Module 9: Data Integration",
    "section": "Why Data Integration?",
    "text": "Why Data Integration?\nChallenges: - Technical variation between experiments - Different sequencing depths - Platform differences - Sample preparation variations\nGoals: - Remove technical variation - Preserve biological variation - Enable cross-study comparisons"
  },
  {
    "objectID": "modules/09-data-integration.html#batch-effects",
    "href": "modules/09-data-integration.html#batch-effects",
    "title": "Module 9: Data Integration",
    "section": "Batch Effects",
    "text": "Batch Effects\n\nSources of Batch Effects\n\nDifferent laboratories\nDifferent sequencing runs\nDifferent 10x chip lanes\nDifferent operators\nDifferent time points\nDifferent protocols\n\n\n\nDetecting Batch Effects\nimport scanpy as sc\n\n# Visualize before integration\nsc.pl.umap(adata, color=['batch', 'cell_type'])\n\n# Check mixing with kBET or LISI"
  },
  {
    "objectID": "modules/09-data-integration.html#integration-methods",
    "href": "modules/09-data-integration.html#integration-methods",
    "title": "Module 9: Data Integration",
    "section": "Integration Methods",
    "text": "Integration Methods\n\n1. Harmony\nimport scanpy.external as sce\n\n# Run Harmony\nsce.pp.harmony_integrate(adata, key='batch')\n\n# Compute UMAP on integrated space\nsc.pp.neighbors(adata, use_rep='X_pca_harmony')\nsc.tl.umap(adata)\n\n# Visualize\nsc.pl.umap(adata, color=['batch', 'cell_type'])\n\n\n2. Scanorama\nimport scanorama\n\n# Split by batch\nadatas = [adata[adata.obs['batch'] == b] for b in adata.obs['batch'].unique()]\n\n# Integrate\nscanorama.integrate_scanpy(adatas, dimred=50)\n\n# Merge back\nadata_integrated = adatas[0].concatenate(adatas[1:])\n\n\n3. Combat\nfrom scanpy.pp import combat\n\n# Apply Combat\nsc.pp.combat(adata, key='batch')\n\n\n4. BBKNN\nimport bbknn\n\n# Run BBKNN\nbbknn.bbknn(adata, batch_key='batch', n_pcs=30)\n\n# Compute UMAP\nsc.tl.umap(adata)\n\n\n5. Seurat Integration (via R)\n# Export to h5ad\nadata.write('data_for_seurat.h5ad')\n\n# Run in R:\n# library(Seurat)\n# library(SeuratDisk)\n# Convert(\"data_for_seurat.h5ad\", dest=\"h5seurat\")\n# seurat_obj &lt;- LoadH5Seurat(\"data_for_seurat.h5seurat\")\n# # Run Seurat integration"
  },
  {
    "objectID": "modules/09-data-integration.html#comparison-of-methods",
    "href": "modules/09-data-integration.html#comparison-of-methods",
    "title": "Module 9: Data Integration",
    "section": "Comparison of Methods",
    "text": "Comparison of Methods\n\n\n\nMethod\nSpeed\nPreservation\nBest For\n\n\n\n\nHarmony\nFast\nGood\nLarge datasets\n\n\nScanorama\nMedium\nGood\nMultiple batches\n\n\nCombat\nFast\nModerate\nSimple batch effects\n\n\nBBKNN\nFast\nGood\nGraph-based analyses\n\n\nSeurat\nSlow\nExcellent\nSmall-medium datasets"
  },
  {
    "objectID": "modules/09-data-integration.html#evaluating-integration",
    "href": "modules/09-data-integration.html#evaluating-integration",
    "title": "Module 9: Data Integration",
    "section": "Evaluating Integration",
    "text": "Evaluating Integration\n\nVisual Assessment\n# Before and after comparison\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\nsc.pl.umap(adata_raw, color='batch', ax=ax1, show=False, title='Before')\nsc.pl.umap(adata_int, color='batch', ax=ax2, show=False, title='After')\n\n# Check biological signal preservation\nsc.pl.umap(adata_int, color=['batch', 'cell_type', 'marker_gene'])\n\n\nQuantitative Metrics\n# Calculate LISI (Local Inverse Simpson's Index)\nimport lisi\n\n# Integration score (iLISI)\nilisi = lisi.compute_lisi(adata.obsm['X_pca'], adata.obs[['batch']], ['batch'])\n\n# Conservation score (cLISI)\nclisi = lisi.compute_lisi(adata.obsm['X_pca'], adata.obs[['cell_type']], ['cell_type'])\n\n\nCell Type Mixing\n# Check if same cell types from different batches mix\nfor cell_type in adata.obs['cell_type'].unique():\n    subset = adata[adata.obs['cell_type'] == cell_type]\n    sc.pl.umap(subset, color='batch', title=f'{cell_type}')"
  },
  {
    "objectID": "modules/09-data-integration.html#best-practices",
    "href": "modules/09-data-integration.html#best-practices",
    "title": "Module 9: Data Integration",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipIntegration Tips\n\n\n\n\nAlways visualize data before integration\nTry multiple methods and compare\nVerify biological signal preservation\nDon’t over-integrate (can remove biology)\nKeep unintegrated data for reference\nConsider integration necessity"
  },
  {
    "objectID": "modules/09-data-integration.html#when-not-to-integrate",
    "href": "modules/09-data-integration.html#when-not-to-integrate",
    "title": "Module 9: Data Integration",
    "section": "When NOT to Integrate",
    "text": "When NOT to Integrate\n\nStudying batch-specific effects\nTruly different biological conditions\nDevelopmental time series\nPerturbation experiments"
  },
  {
    "objectID": "modules/09-data-integration.html#practical-workflow",
    "href": "modules/09-data-integration.html#practical-workflow",
    "title": "Module 9: Data Integration",
    "section": "Practical Workflow",
    "text": "Practical Workflow\n# 1. Load and QC all datasets\nadata1 = sc.read_10x_mtx('sample1/')\nadata2 = sc.read_10x_mtx('sample2/')\n\n# 2. QC each dataset separately\nfor adata in [adata1, adata2]:\n    sc.pp.filter_cells(adata, min_genes=200)\n    sc.pp.filter_genes(adata, min_cells=3)\n\n# 3. Merge datasets\nadata = adata1.concatenate(adata2, batch_key='batch')\n\n# 4. Standard preprocessing\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, batch_key='batch')\n\n# 5. Visualize before integration\nsc.pp.pca(adata)\nsc.pp.neighbors(adata)\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='batch')\n\n# 6. Integrate\nsce.pp.harmony_integrate(adata, key='batch')\n\n# 7. Re-compute neighbors and UMAP\nsc.pp.neighbors(adata, use_rep='X_pca_harmony')\nsc.tl.umap(adata)\n\n# 8. Visualize after integration\nsc.pl.umap(adata, color=['batch', 'cell_type'])\n\n# 9. Evaluate integration\n# Check mixing and biological signal"
  },
  {
    "objectID": "modules/09-data-integration.html#handling-different-integration-scenarios",
    "href": "modules/09-data-integration.html#handling-different-integration-scenarios",
    "title": "Module 9: Data Integration",
    "section": "Handling Different Integration Scenarios",
    "text": "Handling Different Integration Scenarios\n\nSame Cell Types, Different Batches\n# Use aggressive integration\nsce.pp.harmony_integrate(adata, key='batch', theta=2)\n\n\nDifferent Conditions\n# Use mild integration\nsce.pp.harmony_integrate(adata, key='batch', theta=0.5)\n\n\nMultiple Batch Variables\n# Integrate multiple factors\nsce.pp.harmony_integrate(adata, key=['batch', 'donor', 'lane'])"
  },
  {
    "objectID": "modules/09-data-integration.html#practical-exercise",
    "href": "modules/09-data-integration.html#practical-exercise",
    "title": "Module 9: Data Integration",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad two or more single-cell datasets\nVisualize batch effects\nApply 2-3 integration methods\nCompare results qualitatively\nEvaluate integration quality\nChoose best method for your data"
  },
  {
    "objectID": "modules/09-data-integration.html#key-takeaways",
    "href": "modules/09-data-integration.html#key-takeaways",
    "title": "Module 9: Data Integration",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nBatch effects are common in scRNA-seq\nMultiple integration methods available\nNo single best method for all cases\nEvaluate both mixing and biology preservation\nOver-integration can remove real biology"
  },
  {
    "objectID": "modules/09-data-integration.html#additional-resources",
    "href": "modules/09-data-integration.html#additional-resources",
    "title": "Module 9: Data Integration",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nBenchmarking Integration Methods\nHarmony Documentation\nIntegration Best Practices"
  },
  {
    "objectID": "modules/09-data-integration.html#next-module",
    "href": "modules/09-data-integration.html#next-module",
    "title": "Module 9: Data Integration",
    "section": "Next Module",
    "text": "Next Module\nWith integrated data, let’s identify cell populations through clustering!\nContinue to Module 10: Clustering →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/07-quality-control.html",
    "href": "modules/07-quality-control.html",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "",
    "text": "Quality control is crucial for single-cell RNA-seq analysis. This module covers identifying and filtering low-quality cells and genes.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand QC metrics for single-cell data\nIdentify low-quality cells and doublets\nFilter genes and cells\nHandle batch effects\nVisualize QC metrics"
  },
  {
    "objectID": "modules/07-quality-control.html#overview",
    "href": "modules/07-quality-control.html#overview",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "",
    "text": "Quality control is crucial for single-cell RNA-seq analysis. This module covers identifying and filtering low-quality cells and genes.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand QC metrics for single-cell data\nIdentify low-quality cells and doublets\nFilter genes and cells\nHandle batch effects\nVisualize QC metrics"
  },
  {
    "objectID": "modules/07-quality-control.html#why-quality-control",
    "href": "modules/07-quality-control.html#why-quality-control",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Why Quality Control?",
    "text": "Why Quality Control?\nPoor quality data leads to: - Spurious biological conclusions - Incorrect cell type identification - False differential expression - Wasted computational resources"
  },
  {
    "objectID": "modules/07-quality-control.html#key-qc-metrics",
    "href": "modules/07-quality-control.html#key-qc-metrics",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Key QC Metrics",
    "text": "Key QC Metrics\n\nCell-Level Metrics\n\nEssential metrics:\n\nNumber of genes detected (nGene or nFeature)\nTotal UMI counts (nUMI or nCount)\nMitochondrial gene percentage (percent.mt)\nRibosomal gene percentage (percent.ribo)\nComplexity (log10GenesPerUMI)\n\n\n\n\nGene-Level Metrics\n\nGenes detected in how many cells\nMean expression level\nVariance/dispersion"
  },
  {
    "objectID": "modules/07-quality-control.html#loading-data",
    "href": "modules/07-quality-control.html#loading-data",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Loading Data",
    "text": "Loading Data\nimport scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load 10x data\nadata = sc.read_10x_mtx('filtered_matrix/', var_names='gene_symbols')\n\n# View data structure\nprint(adata)"
  },
  {
    "objectID": "modules/07-quality-control.html#calculating-qc-metrics",
    "href": "modules/07-quality-control.html#calculating-qc-metrics",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Calculating QC Metrics",
    "text": "Calculating QC Metrics\n# Identify mitochondrial genes\nadata.var['mt'] = adata.var_names.str.startswith('MT-')\n\n# Identify ribosomal genes\nadata.var['ribo'] = adata.var_names.str.startswith(('RPS', 'RPL'))\n\n# Calculate QC metrics\nsc.pp.calculate_qc_metrics(\n    adata,\n    qc_vars=['mt', 'ribo'],\n    percent_top=None,\n    log1p=False,\n    inplace=True\n)"
  },
  {
    "objectID": "modules/07-quality-control.html#visualizing-qc-metrics",
    "href": "modules/07-quality-control.html#visualizing-qc-metrics",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Visualizing QC Metrics",
    "text": "Visualizing QC Metrics\n\nViolin Plots\nsc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'],\n             jitter=0.4, multi_panel=True)\n\n\nScatter Plots\nsc.pl.scatter(adata, x='total_counts', y='pct_counts_mt')\nsc.pl.scatter(adata, x='total_counts', y='n_genes_by_counts')\n\n\nDistribution Plots\n# Histogram\nplt.hist(adata.obs['n_genes_by_counts'], bins=100)\nplt.xlabel('Number of genes')\nplt.ylabel('Number of cells')\nplt.show()"
  },
  {
    "objectID": "modules/07-quality-control.html#setting-filtering-thresholds",
    "href": "modules/07-quality-control.html#setting-filtering-thresholds",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Setting Filtering Thresholds",
    "text": "Setting Filtering Thresholds\n\nStatistical Approach (MAD)\ndef is_outlier(adata, metric, nmads=5):\n    \"\"\"Identify outliers using median absolute deviation.\"\"\"\n    M = adata.obs[metric]\n    outlier = (M &lt; np.median(M) - nmads * median_abs_deviation(M)) | \\\n              (np.median(M) + nmads * median_abs_deviation(M) &lt; M)\n    return outlier\n\nfrom scipy.stats import median_abs_deviation\n\n# Identify outliers\nadata.obs['outlier_genes'] = is_outlier(adata, 'n_genes_by_counts')\nadata.obs['outlier_counts'] = is_outlier(adata, 'total_counts')\nadata.obs['outlier_mt'] = is_outlier(adata, 'pct_counts_mt')\n\n\nManual Thresholds\n# Define thresholds based on data exploration\nmin_genes = 200\nmax_genes = 5000\nmax_mt = 5  # 5%\nmin_counts = 500\nmax_counts = 25000"
  },
  {
    "objectID": "modules/07-quality-control.html#cell-filtering",
    "href": "modules/07-quality-control.html#cell-filtering",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Cell Filtering",
    "text": "Cell Filtering\n\nApply Filters\n# Filter cells\nsc.pp.filter_cells(adata, min_genes=min_genes)\n\n# Manual filtering\nadata = adata[adata.obs['n_genes_by_counts'] &lt; max_genes, :]\nadata = adata[adata.obs['pct_counts_mt'] &lt; max_mt, :]\nadata = adata[adata.obs['total_counts'] &gt; min_counts, :]\nadata = adata[adata.obs['total_counts'] &lt; max_counts, :]\n\nprint(f\"Remaining cells: {adata.n_obs}\")\n\n\nVisualize Filtering\n# Before and after\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\naxes[0].scatter(adata_raw.obs['total_counts'],\n                adata_raw.obs['n_genes_by_counts'],\n                alpha=0.5)\naxes[0].set_title('Before filtering')\naxes[1].scatter(adata.obs['total_counts'],\n                adata.obs['n_genes_by_counts'],\n                alpha=0.5)\naxes[1].set_title('After filtering')"
  },
  {
    "objectID": "modules/07-quality-control.html#gene-filtering",
    "href": "modules/07-quality-control.html#gene-filtering",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Gene Filtering",
    "text": "Gene Filtering\n# Filter genes expressed in minimum number of cells\nsc.pp.filter_genes(adata, min_cells=3)\n\n# Remove mitochondrial genes (optional)\nadata = adata[:, ~adata.var['mt']]\n\n# Remove ribosomal genes (optional)\nadata = adata[:, ~adata.var['ribo']]\n\nprint(f\"Remaining genes: {adata.n_vars}\")"
  },
  {
    "objectID": "modules/07-quality-control.html#doublet-detection",
    "href": "modules/07-quality-control.html#doublet-detection",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Doublet Detection",
    "text": "Doublet Detection\n\nScrublet\nimport scrublet as scr\n\n# Run Scrublet\nscrub = scr.Scrublet(adata.X)\ndoublet_scores, predicted_doublets = scrub.scrub_doublets()\n\n# Add to adata\nadata.obs['doublet_scores'] = doublet_scores\nadata.obs['predicted_doublets'] = predicted_doublets\n\n# Visualize\nscrub.plot_histogram()\n\n# Filter doublets\nadata = adata[~adata.obs['predicted_doublets'], :]"
  },
  {
    "objectID": "modules/07-quality-control.html#sample-specific-qc",
    "href": "modules/07-quality-control.html#sample-specific-qc",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Sample-Specific QC",
    "text": "Sample-Specific QC\nWhen analyzing multiple samples:\n# Visualize QC by sample\nsc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'],\n             groupby='sample', rotation=45)\n\n# Filter per sample\nfor sample in adata.obs['sample'].unique():\n    sample_cells = adata.obs['sample'] == sample\n    # Apply sample-specific thresholds"
  },
  {
    "objectID": "modules/07-quality-control.html#ambient-rna-correction",
    "href": "modules/07-quality-control.html#ambient-rna-correction",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Ambient RNA Correction",
    "text": "Ambient RNA Correction\n\nSoupX or CellBender\n# CellBender example (run before Python analysis)\ncellbender remove-background \\\n    --input raw_feature_bc_matrix.h5 \\\n    --output output.h5 \\\n    --expected-cells 5000 \\\n    --total-droplets-included 25000"
  },
  {
    "objectID": "modules/07-quality-control.html#saving-filtered-data",
    "href": "modules/07-quality-control.html#saving-filtered-data",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Saving Filtered Data",
    "text": "Saving Filtered Data\n# Save filtered data\nadata.write('filtered_adata.h5ad')\n\n# Save metadata\nadata.obs.to_csv('filtered_metadata.csv')\n\n# Export filtered counts\nadata.X.tofile('filtered_counts.csv')"
  },
  {
    "objectID": "modules/07-quality-control.html#best-practices",
    "href": "modules/07-quality-control.html#best-practices",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipQuality Control Tips\n\n\n\n\nPlot QC metrics before filtering\nUse both statistical and manual thresholds\nDocument filtering decisions\nSave unfiltered data\nCheck for batch effects\nValidate with known markers\nBe conservative with filtering"
  },
  {
    "objectID": "modules/07-quality-control.html#common-pitfalls",
    "href": "modules/07-quality-control.html#common-pitfalls",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nOver-filtering (removing real biology)\nUnder-filtering (keeping low-quality cells)\nUsing same thresholds for all samples\nIgnoring sample-specific effects\nNot checking doublets"
  },
  {
    "objectID": "modules/07-quality-control.html#practical-exercise",
    "href": "modules/07-quality-control.html#practical-exercise",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad a single-cell dataset\nCalculate and visualize QC metrics\nIdentify appropriate filtering thresholds\nApply filtering\nDetect and remove doublets\nSave cleaned data"
  },
  {
    "objectID": "modules/07-quality-control.html#key-takeaways",
    "href": "modules/07-quality-control.html#key-takeaways",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nQC is the most important step in scRNA-seq analysis\nMultiple metrics should be considered\nThresholds should be data-driven\nDoublet detection is essential\nDocument all filtering decisions"
  },
  {
    "objectID": "modules/07-quality-control.html#additional-resources",
    "href": "modules/07-quality-control.html#additional-resources",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nScanpy QC Tutorial\nOrchestrating Single-Cell Analysis\nCurrent Best Practices"
  },
  {
    "objectID": "modules/07-quality-control.html#next-module",
    "href": "modules/07-quality-control.html#next-module",
    "title": "Module 7: Quality Control in Single-Cell Analysis",
    "section": "Next Module",
    "text": "Next Module\nWith clean data, let’s explore dimensionality reduction!\nContinue to Module 8: Dimensionality Reduction →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/05-python-part1.html",
    "href": "modules/05-python-part1.html",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "",
    "text": "Python is the primary language for bioinformatics and data science. This module introduces Python fundamentals including data types, control structures, and functions.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nSet up Python environment\nUnderstand basic data types and variables\nUse control flow statements\nWrite and call functions\nWork with strings and lists\nHandle errors and exceptions"
  },
  {
    "objectID": "modules/05-python-part1.html#overview",
    "href": "modules/05-python-part1.html#overview",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "",
    "text": "Python is the primary language for bioinformatics and data science. This module introduces Python fundamentals including data types, control structures, and functions.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nSet up Python environment\nUnderstand basic data types and variables\nUse control flow statements\nWrite and call functions\nWork with strings and lists\nHandle errors and exceptions"
  },
  {
    "objectID": "modules/05-python-part1.html#why-python-for-bioinformatics",
    "href": "modules/05-python-part1.html#why-python-for-bioinformatics",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Why Python for Bioinformatics?",
    "text": "Why Python for Bioinformatics?\n\nReadability: Clean, easy-to-understand syntax\nLibraries: Rich ecosystem (Scanpy, Pandas, NumPy)\nCommunity: Large user base and support\nVersatility: Data analysis, visualization, machine learning\nIntegration: Works well with other tools"
  },
  {
    "objectID": "modules/05-python-part1.html#getting-started",
    "href": "modules/05-python-part1.html#getting-started",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Getting Started",
    "text": "Getting Started\n\nInstallation Options\nAnaconda (Recommended)\n# Download and install Anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-latest-Linux-x86_64.sh\nbash Anaconda3-latest-Linux-x86_64.sh\n\n# Create environment\nconda create -n brain python=3.10\nconda activate brain\nPip\npip install jupyter numpy pandas matplotlib seaborn scanpy\n\n\nRunning Python\npython script.py        # Run a script\npython                  # Interactive Python\njupyter notebook        # Launch Jupyter\nipython                 # Enhanced interactive Python"
  },
  {
    "objectID": "modules/05-python-part1.html#basic-syntax",
    "href": "modules/05-python-part1.html#basic-syntax",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Basic Syntax",
    "text": "Basic Syntax\n\nVariables and Data Types\n# Numbers\nage = 25\npi = 3.14159\n\n# Strings\nname = \"neuron\"\ngene = 'BDNF'\n\n# Boolean\nis_expressed = True\n\n# Check type\nprint(type(age))  # &lt;class 'int'&gt;\n\n\nBasic Operations\n# Arithmetic\nx = 10 + 5   # Addition\ny = 10 - 5   # Subtraction\nz = 10 * 5   # Multiplication\nw = 10 / 5   # Division\nmod = 10 % 3 # Modulus\nexp = 2 ** 3 # Exponent\n\n# String operations\nfull_name = \"first\" + \" \" + \"last\"\nrepeated = \"ATG\" * 3  # \"ATGATGATG\""
  },
  {
    "objectID": "modules/05-python-part1.html#data-structures",
    "href": "modules/05-python-part1.html#data-structures",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Data Structures",
    "text": "Data Structures\n\nLists\n# Create lists\ngenes = [\"BDNF\", \"SYN1\", \"GFAP\", \"MBP\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\n\n# Access elements\nfirst_gene = genes[0]     # \"BDNF\"\nlast_gene = genes[-1]     # \"MBP\"\n\n# Slicing\nfirst_two = genes[0:2]    # [\"BDNF\", \"SYN1\"]\n\n# Modify lists\ngenes.append(\"NeuN\")      # Add to end\ngenes.insert(0, \"DCX\")    # Insert at position\ngenes.remove(\"GFAP\")      # Remove by value\npopped = genes.pop()      # Remove and return last\n\n# List operations\nlength = len(genes)\nsorted_genes = sorted(genes)\n\n\nDictionaries\n# Create dictionary\ncell_counts = {\n    \"neurons\": 1000,\n    \"astrocytes\": 500,\n    \"microglia\": 200\n}\n\n# Access values\nneuron_count = cell_counts[\"neurons\"]\n\n# Add/modify\ncell_counts[\"oligodendrocytes\"] = 300\n\n# Methods\nkeys = cell_counts.keys()\nvalues = cell_counts.values()\nitems = cell_counts.items()\n\n# Check existence\nif \"neurons\" in cell_counts:\n    print(\"Neurons found\")\n\n\nTuples and Sets\n# Tuples (immutable)\ncoordinates = (10, 20, 30)\nx, y, z = coordinates  # Unpacking\n\n# Sets (unique elements)\ncell_types = {\"neuron\", \"astrocyte\", \"microglia\"}\ncell_types.add(\"oligodendrocyte\")\ncell_types.remove(\"microglia\")"
  },
  {
    "objectID": "modules/05-python-part1.html#control-flow",
    "href": "modules/05-python-part1.html#control-flow",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Control Flow",
    "text": "Control Flow\n\nConditional Statements\n# If-elif-else\nexpression_level = 100\n\nif expression_level &gt; 100:\n    print(\"High expression\")\nelif expression_level &gt; 50:\n    print(\"Medium expression\")\nelse:\n    print(\"Low expression\")\n\n# Ternary operator\nstatus = \"expressed\" if expression_level &gt; 10 else \"not expressed\"\n\n\nLoops\n# For loop\ngenes = [\"BDNF\", \"SYN1\", \"GFAP\"]\nfor gene in genes:\n    print(f\"Processing {gene}\")\n\n# With index\nfor i, gene in enumerate(genes):\n    print(f\"{i}: {gene}\")\n\n# While loop\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count += 1\n\n# List comprehension\nsquared = [x**2 for x in range(10)]\nexpressed_genes = [g for g in genes if len(g) &gt; 3]"
  },
  {
    "objectID": "modules/05-python-part1.html#functions",
    "href": "modules/05-python-part1.html#functions",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Functions",
    "text": "Functions\n\nDefining Functions\n# Basic function\ndef greet(name):\n    \"\"\"Greet a person by name.\"\"\"\n    return f\"Hello, {name}!\"\n\n# Function with default arguments\ndef calculate_tpm(counts, length=1000):\n    \"\"\"Calculate transcripts per million.\"\"\"\n    rate = counts / length\n    tpm = rate * 1e6\n    return tpm\n\n# Multiple return values\ndef get_stats(values):\n    \"\"\"Return mean and std of values.\"\"\"\n    mean = sum(values) / len(values)\n    std = calculate_std(values)\n    return mean, std\n\n# Call function\nresult = greet(\"Alice\")\nmean, std = get_stats([1, 2, 3, 4, 5])\n\n\nLambda Functions\n# Anonymous function\nsquare = lambda x: x ** 2\n\n# With map\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\n\n# With filter\nevens = list(filter(lambda x: x % 2 == 0, numbers))"
  },
  {
    "objectID": "modules/05-python-part1.html#working-with-strings",
    "href": "modules/05-python-part1.html#working-with-strings",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Working with Strings",
    "text": "Working with Strings\n\nString Methods\nsequence = \"ATGCGATCGATCG\"\n\n# Case conversion\nlower = sequence.lower()\nupper = sequence.upper()\n\n# Searching\nposition = sequence.find(\"GAT\")\ncount = sequence.count(\"AT\")\n\n# Splitting and joining\nwords = \"neuron astrocyte microglia\".split()\njoined = \"-\".join(words)\n\n# Replacing\nnew_seq = sequence.replace(\"A\", \"T\")\n\n# Stripping whitespace\nclean = \"  text  \".strip()\n\n\nString Formatting\ngene = \"BDNF\"\nexpression = 123.456\n\n# f-strings (recommended)\nmessage = f\"{gene} expression: {expression:.2f}\"\n\n# format method\nmessage = \"{} expression: {:.2f}\".format(gene, expression)\n\n# Old style\nmessage = \"%s expression: %.2f\" % (gene, expression)"
  },
  {
    "objectID": "modules/05-python-part1.html#file-io",
    "href": "modules/05-python-part1.html#file-io",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "File I/O",
    "text": "File I/O\n\nReading Files\n# Read entire file\nwith open(\"data.txt\", \"r\") as f:\n    content = f.read()\n\n# Read line by line\nwith open(\"data.txt\", \"r\") as f:\n    for line in f:\n        process(line.strip())\n\n# Read all lines into list\nwith open(\"data.txt\", \"r\") as f:\n    lines = f.readlines()\n\n\nWriting Files\n# Write to file\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"Hello, World!\\n\")\n\n# Append to file\nwith open(\"output.txt\", \"a\") as f:\n    f.write(\"New line\\n\")"
  },
  {
    "objectID": "modules/05-python-part1.html#error-handling",
    "href": "modules/05-python-part1.html#error-handling",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Error Handling",
    "text": "Error Handling\n\nTry-Except\ntry:\n    value = int(input(\"Enter a number: \"))\n    result = 100 / value\nexcept ValueError:\n    print(\"Invalid input\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    print(\"Cleanup code\")"
  },
  {
    "objectID": "modules/05-python-part1.html#practical-exercises",
    "href": "modules/05-python-part1.html#practical-exercises",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Practical Exercises",
    "text": "Practical Exercises\n\n\n\n\n\n\nImportantHands-On Practice\n\n\n\n\nCreate a function to calculate GC content\nParse a FASTA file\nCount k-mers in a sequence\nFilter genes by expression threshold\nCalculate basic statistics"
  },
  {
    "objectID": "modules/05-python-part1.html#key-takeaways",
    "href": "modules/05-python-part1.html#key-takeaways",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nPython has clean, readable syntax\nLists and dictionaries are fundamental data structures\nFunctions enable code reuse\nControl flow structures handle logic\nFile I/O is essential for data processing\nError handling prevents crashes"
  },
  {
    "objectID": "modules/05-python-part1.html#additional-resources",
    "href": "modules/05-python-part1.html#additional-resources",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nPython Official Tutorial\nPython for Biologists\nReal Python Tutorials"
  },
  {
    "objectID": "modules/05-python-part1.html#next-module",
    "href": "modules/05-python-part1.html#next-module",
    "title": "Module 5: Fundamentals of Python - Part 1",
    "section": "Next Module",
    "text": "Next Module\nBuild on these foundations with advanced Python concepts!\nContinue to Module 6: Fundamentals of Python Part 2 →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html",
    "href": "modules/03-linux-fundamentals.html",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "",
    "text": "The command line is an essential tool for bioinformatics analysis. This module covers fundamental Linux/Unix commands and concepts needed for working with genomics data.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nNavigate the Linux file system\nExecute basic file operations\nUse text processing tools\nUnderstand permissions and processes\nWrite simple shell scripts\nWork with remote servers"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#overview",
    "href": "modules/03-linux-fundamentals.html#overview",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "",
    "text": "The command line is an essential tool for bioinformatics analysis. This module covers fundamental Linux/Unix commands and concepts needed for working with genomics data.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nNavigate the Linux file system\nExecute basic file operations\nUse text processing tools\nUnderstand permissions and processes\nWrite simple shell scripts\nWork with remote servers"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#why-learn-the-command-line",
    "href": "modules/03-linux-fundamentals.html#why-learn-the-command-line",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Why Learn the Command Line?",
    "text": "Why Learn the Command Line?\n\nEfficiency: Automate repetitive tasks\nPower: Handle large datasets\nReproducibility: Script-based workflows\nRequired: Most bioinformatics tools are command-line based\nUniversal: Skills transferable across platforms"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#getting-started",
    "href": "modules/03-linux-fundamentals.html#getting-started",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Getting Started",
    "text": "Getting Started\n\nAccessing the Terminal\n\nLinux: Built-in terminal\nmacOS: Terminal.app or iTerm2\nWindows: WSL2 (Windows Subsystem for Linux)\n\n\n\nBasic Command Structure\ncommand -options arguments"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#essential-commands",
    "href": "modules/03-linux-fundamentals.html#essential-commands",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Essential Commands",
    "text": "Essential Commands\n\nNavigation\npwd              # Print working directory\nls               # List files\nls -lh           # Detailed list with human-readable sizes\ncd directory     # Change directory\ncd ..            # Go up one level\ncd ~             # Go to home directory\n\n\nFile Operations\nmkdir dirname          # Create directory\ntouch filename         # Create empty file\ncp source dest         # Copy files\nmv source dest         # Move/rename files\nrm filename            # Remove file\nrm -r directory        # Remove directory recursively\n\n\nViewing Files\ncat file.txt           # Display entire file\nless file.txt          # View file page by page\nhead -n 10 file.txt    # First 10 lines\ntail -n 10 file.txt    # Last 10 lines\nwc -l file.txt         # Count lines"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#text-processing",
    "href": "modules/03-linux-fundamentals.html#text-processing",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Text Processing",
    "text": "Text Processing\n\nSearching and Filtering\ngrep \"pattern\" file.txt        # Search for pattern\ngrep -i \"pattern\" file.txt     # Case-insensitive search\ngrep -v \"pattern\" file.txt     # Invert match\n\n\nSorting and Unique\nsort file.txt                  # Sort lines\nsort -n file.txt               # Numeric sort\nuniq file.txt                  # Remove duplicates\nsort file.txt | uniq -c        # Count occurrences\n\n\nCutting and Pasting\ncut -f 1,3 file.tsv            # Extract columns 1 and 3\ncut -d ',' -f 2 file.csv       # CSV column extraction\npaste file1.txt file2.txt      # Merge files side by side"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#pipes-and-redirection",
    "href": "modules/03-linux-fundamentals.html#pipes-and-redirection",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Pipes and Redirection",
    "text": "Pipes and Redirection\n\nChaining Commands\ncommand1 | command2            # Pipe output to next command\nls -lh | grep \".txt\"           # List only .txt files\ncat file.txt | sort | uniq     # Sort and remove duplicates\n\n\nRedirection\ncommand &gt; output.txt           # Write output to file\ncommand &gt;&gt; output.txt          # Append to file\ncommand 2&gt; error.log           # Redirect errors\ncommand &&gt; all.log             # Redirect both stdout and stderr"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#working-with-compressed-files",
    "href": "modules/03-linux-fundamentals.html#working-with-compressed-files",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Working with Compressed Files",
    "text": "Working with Compressed Files\ngzip file.txt                  # Compress file\ngunzip file.txt.gz             # Decompress file\nzcat file.txt.gz               # View compressed file\ntar -czf archive.tar.gz dir/   # Create tar.gz archive\ntar -xzf archive.tar.gz        # Extract tar.gz archive"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#permissions-and-processes",
    "href": "modules/03-linux-fundamentals.html#permissions-and-processes",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Permissions and Processes",
    "text": "Permissions and Processes\n\nFile Permissions\nls -l                          # View permissions\nchmod +x script.sh             # Make executable\nchmod 755 file                 # Set specific permissions\nchown user:group file          # Change ownership\n\n\nProcess Management\ntop                            # View running processes\nps aux                         # List all processes\nkill PID                       # Kill process by ID\nCtrl+C                         # Interrupt current process\nCtrl+Z                         # Suspend current process\nbg                             # Resume in background\nfg                             # Resume in foreground"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#shell-scripting-basics",
    "href": "modules/03-linux-fundamentals.html#shell-scripting-basics",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Shell Scripting Basics",
    "text": "Shell Scripting Basics\n\nCreating a Script\n#!/bin/bash\n# My first bioinformatics script\n\necho \"Processing data...\"\nmkdir -p results\ncp data/*.fastq.gz results/\necho \"Done!\"\n\n\nVariables\nNAME=\"sample1\"\nINPUT_DIR=\"/path/to/data\"\necho \"Processing ${NAME}\"\n\n\nLoops\n# For loop\nfor file in *.txt; do\n    echo \"Processing $file\"\n    wc -l $file\ndone\n\n# While loop\ncounter=1\nwhile [ $counter -le 5 ]; do\n    echo \"Count: $counter\"\n    ((counter++))\ndone"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#remote-server-access",
    "href": "modules/03-linux-fundamentals.html#remote-server-access",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Remote Server Access",
    "text": "Remote Server Access\n\nSSH (Secure Shell)\nssh username@server.com        # Connect to remote server\nscp file.txt user@server:~/    # Copy file to server\nrsync -avz dir/ server:~/dir/  # Sync directories"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#bioinformatics-specific-commands",
    "href": "modules/03-linux-fundamentals.html#bioinformatics-specific-commands",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Bioinformatics-Specific Commands",
    "text": "Bioinformatics-Specific Commands\n\nWorking with FASTQ Files\n# Count reads\nzcat file.fastq.gz | wc -l\n# Divide by 4 for actual read count\n\n# Extract first 1000 reads\nzcat file.fastq.gz | head -n 4000 | gzip &gt; subset.fastq.gz\n\n# Check quality scores\nzcat file.fastq.gz | head -n 100\n\n\nWorking with GTF/GFF Files\n# Extract gene entries\ngrep \"gene\" genes.gtf &gt; genes_only.gtf\n\n# Count features\ncut -f 3 genes.gtf | sort | uniq -c"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#practical-exercises",
    "href": "modules/03-linux-fundamentals.html#practical-exercises",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Practical Exercises",
    "text": "Practical Exercises\n\n\n\n\n\n\nImportantHands-On Practice\n\n\n\n\nCreate a project directory structure\nDownload a sample FASTQ file\nCount the number of reads\nExtract the first 1000 reads\nCalculate basic statistics\nWrite a script to automate the process"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#tips-and-best-practices",
    "href": "modules/03-linux-fundamentals.html#tips-and-best-practices",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Tips and Best Practices",
    "text": "Tips and Best Practices\n\n\n\n\n\n\nTipPro Tips\n\n\n\n\nUse Tab for auto-completion\nUse Up/Down arrows for command history\nUse Ctrl+R for reverse search\nUse man command for help\nUse history to see previous commands\nAlways use absolute paths in scripts\nComment your code\nTest on small datasets first"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#common-pitfalls",
    "href": "modules/03-linux-fundamentals.html#common-pitfalls",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nForgetting to quote filenames with spaces\nNot checking if commands succeeded\nAccidentally deleting important files\nNot backing up data\nWorking in wrong directory"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#key-takeaways",
    "href": "modules/03-linux-fundamentals.html#key-takeaways",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nCommand line is essential for bioinformatics\nMaster basic navigation and file operations\nLearn text processing for data manipulation\nUse pipes to chain commands efficiently\nWrite scripts for reproducible analyses\nPractice regularly to build proficiency"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#additional-resources",
    "href": "modules/03-linux-fundamentals.html#additional-resources",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nThe Unix Shell (Software Carpentry)\nLinux Command Line Cheat Sheet\nBash scripting tutorial"
  },
  {
    "objectID": "modules/03-linux-fundamentals.html#next-module",
    "href": "modules/03-linux-fundamentals.html#next-module",
    "title": "Module 3: Linux Command Line Fundamentals",
    "section": "Next Module",
    "text": "Next Module\nNow that you have command-line skills, let’s apply them to process single-cell data!\nContinue to Module 4: CellRanger Pipeline →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html",
    "href": "modules/01-intro-neurogenomics.html",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "",
    "text": "This module introduces the field of neurogenomics, exploring how genetic information shapes brain development, function, and disease. You will learn about the fundamental concepts that bridge genomics and neuroscience.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\nBy the end of this module, you will be able to:\n\nDefine neurogenomics and its importance in neuroscience research\nUnderstand the genetic architecture of the brain\nIdentify key neurological disorders with genetic components\nRecognize the role of genomics in understanding brain function\nAppreciate current challenges and opportunities in neurogenomics research"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#overview",
    "href": "modules/01-intro-neurogenomics.html#overview",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "",
    "text": "This module introduces the field of neurogenomics, exploring how genetic information shapes brain development, function, and disease. You will learn about the fundamental concepts that bridge genomics and neuroscience.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\nBy the end of this module, you will be able to:\n\nDefine neurogenomics and its importance in neuroscience research\nUnderstand the genetic architecture of the brain\nIdentify key neurological disorders with genetic components\nRecognize the role of genomics in understanding brain function\nAppreciate current challenges and opportunities in neurogenomics research"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#what-is-neurogenomics",
    "href": "modules/01-intro-neurogenomics.html#what-is-neurogenomics",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "What is Neurogenomics?",
    "text": "What is Neurogenomics?\nNeurogenomics is the study of how the genome influences the development, structure, and function of the nervous system. It combines principles from:\n\nGenomics: Study of entire genomes and their functions\nNeuroscience: Study of the nervous system and brain\nGenetics: Study of heredity and variation in organisms\nMolecular Biology: Study of biological processes at the molecular level"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#the-brain-and-genetic-information",
    "href": "modules/01-intro-neurogenomics.html#the-brain-and-genetic-information",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "The Brain and Genetic Information",
    "text": "The Brain and Genetic Information\n\nComplexity of the Human Brain\n\nApproximately 86 billion neurons\nTrillions of synaptic connections\n~20,000 protein-coding genes expressed in the brain\nComplex spatial and temporal gene expression patterns\n\n\n\nGene Expression in the Brain\n\nDifferent brain regions show distinct gene expression profiles:\n\nCerebral cortex: Higher cognitive functions\nHippocampus: Memory formation and consolidation\nStriatum: Motor control and reward processing\nCerebellum: Motor coordination and learning"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#applications-of-neurogenomics",
    "href": "modules/01-intro-neurogenomics.html#applications-of-neurogenomics",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Applications of Neurogenomics",
    "text": "Applications of Neurogenomics\n\n1. Understanding Brain Development\n\nNeurodevelopmental processes\nCell fate determination\nNeural circuit formation\nSynaptogenesis and plasticity\n\n\n\n2. Neurological Disease Research\n\nGenetic contributions to brain disorders:\n\nAlzheimer’s disease\nParkinson’s disease\nAutism spectrum disorders (ASD)\nSchizophrenia\nEpilepsy\nHuntington’s disease\n\n\n\n\n3. Personalized Medicine\n\nPharmacogenomics for neurological treatments\nGenetic risk assessment\nTargeted therapeutic interventions\nPrecision psychiatry\n\n\n\n4. Evolutionary Neuroscience\n\nBrain evolution across species\nHuman-specific genetic adaptations\nComparative neurogenomics"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#key-technologies-in-neurogenomics",
    "href": "modules/01-intro-neurogenomics.html#key-technologies-in-neurogenomics",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Key Technologies in Neurogenomics",
    "text": "Key Technologies in Neurogenomics\n\nGenomic Technologies\n\nWhole genome sequencing (WGS)\nWhole exome sequencing (WES)\nGenome-wide association studies (GWAS)\nCopy number variation (CNV) analysis\n\n\n\nTranscriptomic Technologies\n\nRNA sequencing (RNA-seq)\nSingle-cell RNA-seq\nSpatial transcriptomics\nSingle-nucleus RNA-seq (snRNA-seq)\n\n\n\nEpigenomic Technologies\n\nChIP-seq (Chromatin immunoprecipitation sequencing)\nATAC-seq (Assay for transposase-accessible chromatin)\nBisulfite sequencing (DNA methylation)"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#important-databases-and-resources",
    "href": "modules/01-intro-neurogenomics.html#important-databases-and-resources",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Important Databases and Resources",
    "text": "Important Databases and Resources\n\n\n\n\n\n\nTipKey Resources\n\n\n\n\nAllen Brain Atlas: Comprehensive gene expression maps\nGTEx Portal: Tissue-specific gene expression\nENCODE: Encyclopedia of DNA elements\nPsychENCODE: Psychiatric disorder genomics\ngnomAD: Genome aggregation database"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#case-studies",
    "href": "modules/01-intro-neurogenomics.html#case-studies",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Case Studies",
    "text": "Case Studies\n\nCase Study 1: APOE and Alzheimer’s Disease\nThe APOE gene has three common variants (ε2, ε3, ε4) that significantly influence Alzheimer’s disease risk:\n\nAPOE-ε4 increases risk and lowers age of onset\nAPOE-ε2 provides protective effects\nExample of common genetic variation affecting brain health\n\n\n\nCase Study 2: Single-Cell Atlases of Brain\nRecent single-cell studies have revealed:\n\nUnprecedented cellular diversity in the brain\nCell-type-specific gene expression signatures\nDisease-associated cell populations\nMolecular mechanisms of brain disorders"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#challenges-in-neurogenomics",
    "href": "modules/01-intro-neurogenomics.html#challenges-in-neurogenomics",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Challenges in Neurogenomics",
    "text": "Challenges in Neurogenomics\n\nCellular Heterogeneity: Brain contains hundreds of cell types\nTechnical Limitations: Accessing brain tissue in living subjects\nComplexity: Polygenic nature of most brain disorders\nData Integration: Combining multi-modal datasets\nCausality: Distinguishing correlation from causation"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#future-directions",
    "href": "modules/01-intro-neurogenomics.html#future-directions",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Future Directions",
    "text": "Future Directions\n\nEmerging Trends\n\nMulti-omics integration: Combining genomics, transcriptomics, proteomics\nSingle-cell technologies: Higher resolution cellular analyses\nSpatial genomics: Maintaining tissue context\nAI and machine learning: Analyzing large-scale datasets\nOrganoid models: 3D brain models for functional studies"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#practical-exercise",
    "href": "modules/01-intro-neurogenomics.html#practical-exercise",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\nExplore the Allen Brain Atlas (https://portal.brain-map.org/):\n\nSearch for a gene of interest (e.g., BDNF, SYN1, GFAP)\nExamine its expression pattern across brain regions\nCompare expression levels in different cell types\nReflect on what the expression pattern tells you about gene function"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#key-takeaways",
    "href": "modules/01-intro-neurogenomics.html#key-takeaways",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNeurogenomics bridges genetics and neuroscience to understand brain function\nGenetic variation contributes to brain development, function, and disease\nModern technologies enable unprecedented resolution of brain genomics\nSingle-cell and spatial approaches are revolutionizing the field\nUnderstanding neurogenomics is essential for advancing neuroscience research"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#additional-resources",
    "href": "modules/01-intro-neurogenomics.html#additional-resources",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nRecommended Readings\n\n“Principles of Neurogenomics” - Review article on neurogenomics foundations\n“Single-cell genomics in neuroscience” - Nature Reviews Neuroscience\n“The genomic landscape of neurological disorders” - Recent comprehensive review\n\n\n\nVideo Lectures\n\nAllen Brain Atlas overview and tutorial\nIntroduction to brain cell types and diversity\nGenomic approaches to studying brain disease\n\n\n\nTools and Software\n\nUCSC Genome Browser\nIGV (Integrative Genomics Viewer)\nAllen Brain Atlas portal"
  },
  {
    "objectID": "modules/01-intro-neurogenomics.html#next-module",
    "href": "modules/01-intro-neurogenomics.html#next-module",
    "title": "Module 1: Introduction to Neurogenomics",
    "section": "Next Module",
    "text": "Next Module\nReady to dive deeper into the technologies that make modern neurogenomics possible?\nContinue to Module 2: Introduction to Single-Cell Technology →\n\n\n\n\n\n\n\nNoteQuestions or Feedback?\n\n\n\nIf you have questions about this module, please reach out via the course discussion forum or office hours listed on the Schedule page."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About BRAIN",
    "section": "",
    "text": "Bioinformatics Research with AI in Neurosciences (BRAIN) is a comprehensive research-oriented training program designed to bridge the gap between neuroscience, bioinformatics, and artificial intelligence.\n\n\nOur mission is to empower researchers, students, and professionals with cutting-edge computational skills to analyze complex neurogenomics data and apply AI methods to advance neuroscience research.\n\n\n\nWe envision a future where computational neuroscience and AI-driven approaches are integral to understanding brain function, disease mechanisms, and developing novel therapeutic strategies."
  },
  {
    "objectID": "about.html#about-the-course",
    "href": "about.html#about-the-course",
    "title": "About BRAIN",
    "section": "",
    "text": "Bioinformatics Research with AI in Neurosciences (BRAIN) is a comprehensive research-oriented training program designed to bridge the gap between neuroscience, bioinformatics, and artificial intelligence.\n\n\nOur mission is to empower researchers, students, and professionals with cutting-edge computational skills to analyze complex neurogenomics data and apply AI methods to advance neuroscience research.\n\n\n\nWe envision a future where computational neuroscience and AI-driven approaches are integral to understanding brain function, disease mechanisms, and developing novel therapeutic strategies."
  },
  {
    "objectID": "about.html#course-objectives",
    "href": "about.html#course-objectives",
    "title": "About BRAIN",
    "section": "Course Objectives",
    "text": "Course Objectives\nBy the end of this training program, participants will be able to:\n\nUnderstand the fundamentals of neurogenomics and single-cell technologies\nNavigate and utilize Linux command-line tools for bioinformatics\nProgram in Python for data analysis and visualization\nProcess and analyze single-cell RNA-seq data from raw data to biological insights\nApply quality control, dimensionality reduction, and clustering methods\nPerform differential expression and cell type annotation\nConduct trajectory inference and spatial transcriptomics analyses\nImplement deep learning methods for single-cell genomics\nIntegrate AI approaches into neuroscience research workflows"
  },
  {
    "objectID": "about.html#instructors-team",
    "href": "about.html#instructors-team",
    "title": "About BRAIN",
    "section": "Instructors & Team",
    "text": "Instructors & Team\n\n\n\n\n\n\nNoteCourse Instructors\n\n\n\n\nLead Instructor\n[Name] Title/Position Institution/Organization\nBrief bio and expertise in neurogenomics, bioinformatics, and AI.\n\n\nCo-Instructors\n[Name] Title/Position Institution/Organization\nBrief bio and area of expertise.\n[Name] Title/Position Institution/Organization\nBrief bio and area of expertise."
  },
  {
    "objectID": "about.html#target-audience",
    "href": "about.html#target-audience",
    "title": "About BRAIN",
    "section": "Target Audience",
    "text": "Target Audience\nThis course is designed for:\n\nGraduate students in neuroscience, bioinformatics, or computational biology\nPostdoctoral researchers working with neurogenomics data\nFaculty members looking to expand their computational skills\nBioinformaticians interested in neuroscience applications\nData scientists transitioning to biological research\nMedical researchers studying neurological disorders"
  },
  {
    "objectID": "about.html#prerequisites",
    "href": "about.html#prerequisites",
    "title": "About BRAIN",
    "section": "Prerequisites",
    "text": "Prerequisites\n\n\n\n\n\n\nImportantWhat You Need\n\n\n\nRequired: - Basic understanding of molecular biology and genetics - Access to a computer (Windows, Mac, or Linux) - Willingness to learn programming and command-line tools\nHelpful but not required: - Prior experience with Python or R - Familiarity with Linux/Unix command line - Background in statistics or data analysis"
  },
  {
    "objectID": "about.html#course-philosophy",
    "href": "about.html#course-philosophy",
    "title": "About BRAIN",
    "section": "Course Philosophy",
    "text": "Course Philosophy\n\nHands-On Learning\nWe believe in learning by doing. Every module includes practical exercises with real-world datasets.\n\n\nResearch-Oriented\nCourse materials are based on current research practices and cutting-edge methods used in leading neuroscience laboratories.\n\n\nOpen Science\nWe promote open-source tools, reproducible research practices, and collaborative science.\n\n\nSupportive Environment\nWe foster a welcoming learning environment where questions are encouraged and mistakes are learning opportunities."
  },
  {
    "objectID": "about.html#technical-requirements",
    "href": "about.html#technical-requirements",
    "title": "About BRAIN",
    "section": "Technical Requirements",
    "text": "Technical Requirements\n\nSoftware & Tools\nThroughout the course, you will work with:\n\nOperating System: Linux/Unix (or WSL for Windows users)\nProgramming Languages: Python (primary), bash scripting\nKey Tools:\n\nCellRanger (10x Genomics)\nScanpy (Python single-cell analysis)\nPyTorch/TensorFlow (deep learning)\nJupyter Notebooks\nGit/GitHub\n\n\n\n\nHardware Requirements\n\nMinimum: 8GB RAM, 50GB free disk space\nRecommended: 16GB+ RAM, 100GB+ free disk space\nNote: Some computationally intensive modules may benefit from access to HPC resources"
  },
  {
    "objectID": "about.html#learning-outcomes",
    "href": "about.html#learning-outcomes",
    "title": "About BRAIN",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nUpon successful completion, participants will receive:\n\nCertificate of completion\nPortfolio of coding projects and analyses\nAccess to course materials and resources\nConnection to a community of computational neuroscientists"
  },
  {
    "objectID": "about.html#course-development",
    "href": "about.html#course-development",
    "title": "About BRAIN",
    "section": "Course Development",
    "text": "Course Development\nThis course was developed with support from:\n\n\n[Institution/Organization Name]\n[Funding Agency/Grant Information]\n[Collaborating Institutions]"
  },
  {
    "objectID": "about.html#contact-information",
    "href": "about.html#contact-information",
    "title": "About BRAIN",
    "section": "Contact Information",
    "text": "Contact Information\n\n\n\n\n\n\nNoteGet in Touch\n\n\n\nGeneral Inquiries Email: [course-email@example.com]\nTechnical Support Email: [support@example.com]\nSocial Media - GitHub: @brain-course - Twitter: @brain_course - LinkedIn: BRAIN Course\nOffice Hours Schedule TBA - Check the schedule page for details"
  },
  {
    "objectID": "about.html#frequently-asked-questions",
    "href": "about.html#frequently-asked-questions",
    "title": "About BRAIN",
    "section": "Frequently Asked Questions",
    "text": "Frequently Asked Questions\n\nIs this course suitable for beginners?\nYes! While some modules are advanced, we start with foundations and build progressively. No prior programming experience is required, though it is helpful.\n\n\nWhat is the time commitment?\nEach module requires 2-4 hours for lectures and tutorials, plus 2-3 hours for self-study and practice. Total time commitment is approximately 60-80 hours over 8 weeks.\n\n\nWill I get a certificate?\nYes, participants who complete all modules and meet the requirements will receive a certificate of completion.\n\n\nCan I take individual modules?\nThe course is designed as a comprehensive program with sequential modules. However, some flexibility may be available depending on your background and goals.\n\n\nWhat datasets will we use?\nWe use publicly available neuroscience datasets, including single-cell RNA-seq data from brain tissues, neurological disease models, and developmental studies.\n\n\nIs there a cost to participate?\n[Add information about course fees, if any, or mention that it’s free]"
  },
  {
    "objectID": "about.html#acknowledgments",
    "href": "about.html#acknowledgments",
    "title": "About BRAIN",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nWe would like to thank:\n\nOur students and participants for their engagement and feedback\nThe open-source community for developing the tools we teach\nContributing instructors and teaching assistants\nInstitutions and organizations providing support"
  },
  {
    "objectID": "about.html#stay-connected",
    "href": "about.html#stay-connected",
    "title": "About BRAIN",
    "section": "Stay Connected",
    "text": "Stay Connected\n\n\n\n\n\n\nTipJoin Our Community\n\n\n\nStay updated with course announcements, share resources, and connect with fellow participants.\nBack to Home View Schedule"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to BRAIN",
    "section": "",
    "text": "Master Computational Neuroscience Through Advanced AI & Bioinformatics Training\n\nStart Learning View Schedule"
  },
  {
    "objectID": "modules/02-single-cell-tech.html",
    "href": "modules/02-single-cell-tech.html",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "",
    "text": "Single-cell RNA sequencing (scRNA-seq) has revolutionized our ability to study gene expression at the individual cell level. This module introduces the principles, technologies, and applications of single-cell approaches in neuroscience.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand the principles of single-cell RNA sequencing\nLearn about different scRNA-seq platforms and technologies\nRecognize applications of single-cell approaches in neuroscience\nAppreciate the advantages and limitations of single-cell technologies\nIdentify key experimental design considerations"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#overview",
    "href": "modules/02-single-cell-tech.html#overview",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "",
    "text": "Single-cell RNA sequencing (scRNA-seq) has revolutionized our ability to study gene expression at the individual cell level. This module introduces the principles, technologies, and applications of single-cell approaches in neuroscience.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand the principles of single-cell RNA sequencing\nLearn about different scRNA-seq platforms and technologies\nRecognize applications of single-cell approaches in neuroscience\nAppreciate the advantages and limitations of single-cell technologies\nIdentify key experimental design considerations"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#why-single-cell",
    "href": "modules/02-single-cell-tech.html#why-single-cell",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Why Single-Cell?",
    "text": "Why Single-Cell?\n\nLimitations of Bulk RNA-seq\nTraditional bulk RNA sequencing analyzes the average gene expression across millions of cells, masking:\n\nCellular heterogeneity\nRare cell populations\nCell-state transitions\nCell-type-specific responses\n\n\n\nSingle-Cell Revolution\n\nSingle-cell technologies enable:\n\nCell-type identification and characterization\nDiscovery of rare cell populations\nTrajectory and lineage inference\nCell-state dynamics\nSpatial organization (with spatial methods)"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#single-cell-rna-seq-workflow",
    "href": "modules/02-single-cell-tech.html#single-cell-rna-seq-workflow",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Single-Cell RNA-seq Workflow",
    "text": "Single-Cell RNA-seq Workflow\n\n1. Sample Preparation\n\nTissue dissociation\nCell isolation and purification\nQuality control of cell viability\nCell counting and concentration\n\n\n\n2. Cell Capture & Barcoding\n\nCommon platforms:\n\n10x Genomics Chromium: Droplet-based, high-throughput\nSmart-seq2/3: Full-length transcripts, plate-based\nDrop-seq: Open-source droplet platform\ninDrop: Droplet-based with in-house barcodes\nCITE-seq: Simultaneous RNA and protein\n\n\n\n\n3. Library Preparation\n\nReverse transcription\ncDNA amplification\nLibrary construction\nQuality control\n\n\n\n4. Sequencing\n\nNext-generation sequencing (Illumina)\nSequencing depth considerations\nCost vs. coverage trade-offs\n\n\n\n5. Computational Analysis\n\nRead alignment and quantification\nQuality control and filtering\nNormalization and batch correction\nDimensionality reduction\nClustering and cell type annotation"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#x-genomics-technology",
    "href": "modules/02-single-cell-tech.html#x-genomics-technology",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "10x Genomics Technology",
    "text": "10x Genomics Technology\n\nChromium Platform\nThe most widely used commercial single-cell platform:\n\nKey Features:\n\nDroplet-based cell capture\nGel bead-based barcoding\n3’ or 5’ gene expression profiling\nHigh throughput (500-10,000 cells per sample)\nMultiome capabilities (RNA + ATAC)\n\n\n\n\nHow It Works\n\nCell suspension is loaded into the Chromium controller\nGel beads containing barcoded oligonucleotides\nDroplets encapsulate single cells with gel beads\nCell lysis and reverse transcription within droplets\nUnique barcodes tag each cell’s transcripts\nPool and sequence all cells together"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#applications-in-neuroscience",
    "href": "modules/02-single-cell-tech.html#applications-in-neuroscience",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Applications in Neuroscience",
    "text": "Applications in Neuroscience\n\nBrain Cell Atlas Projects\n\nHuman Cell Atlas\nBRAIN Initiative Cell Census Network (BICCN)\nAllen Brain Cell Atlas\nSpecies-comparative brain atlases\n\n\n\nDisease Research\n\nApplications:\n\nAlzheimer’s disease pathology\nNeuroinflammation in disease\nCancer (glioblastoma) heterogeneity\nNeurodevelopmental disorders\nPsychiatric disorder mechanisms\n\n\n\n\nDevelopment and Aging\n\nBrain development trajectories\nNeurogenesis and gliogenesis\nAging-associated changes\nCellular senescence"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#beyond-standard-scrna-seq",
    "href": "modules/02-single-cell-tech.html#beyond-standard-scrna-seq",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Beyond Standard scRNA-seq",
    "text": "Beyond Standard scRNA-seq\n\nSingle-Nucleus RNA-seq (snRNA-seq)\n\nAdvantages for brain tissue:\n\nWorks with frozen tissue\nCaptures difficult-to-dissociate neurons\nPreserves cell-type proportions better\nReduces dissociation-induced artifacts\n\n\n\n\nSpatial Transcriptomics\n\nVisium (10x Genomics): Spatial gene expression\nMERFISH: Multiplexed error-robust FISH\nseqFISH: Sequential fluorescence in situ hybridization\nSlide-seq: High-resolution spatial sequencing\n\n\n\nMultimodal Technologies\n\nCITE-seq: RNA + surface proteins\nATAC + RNA: Chromatin accessibility and gene expression\nSHARE-seq: Simultaneous RNA and ATAC\nPatch-seq: Electrophysiology + transcriptomics"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#experimental-design-considerations",
    "href": "modules/02-single-cell-tech.html#experimental-design-considerations",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Experimental Design Considerations",
    "text": "Experimental Design Considerations\n\nSample Size\n\nNumber of biological replicates\nCells per sample (technical depth)\nStatistical power considerations\n\n\n\nTechnical Considerations\n\n\n\n\n\n\nImportantKey Factors\n\n\n\n\nFresh vs. frozen tissue\nCell viability requirements\nCapture efficiency (typically 50-80%)\nSequencing depth (reads per cell)\nBatch effects and confounders\n\n\n\n\n\nCost Considerations\n\nPer-cell costs\nSequencing costs\nComputational infrastructure\nTrade-off: more cells vs. deeper sequencing"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#quality-control-metrics",
    "href": "modules/02-single-cell-tech.html#quality-control-metrics",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Quality Control Metrics",
    "text": "Quality Control Metrics\n\nCell-Level QC\n\nNumber of detected genes (complexity)\nTotal UMI counts (sequencing depth)\nMitochondrial content (cell stress/death)\nDoublet detection\n\n\n\nGene-Level QC\n\nGenes detected across cells\nExpression distribution\nTechnical noise estimation"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#challenges-and-limitations",
    "href": "modules/02-single-cell-tech.html#challenges-and-limitations",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Challenges and Limitations",
    "text": "Challenges and Limitations\n\nTechnical noise: Dropout events, amplification bias\nCost: Still expensive for large studies\nComputational demands: Large datasets, complex analyses\nBatch effects: Technical variation across experiments\nInterpretation: Biological meaning of clusters"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#best-practices",
    "href": "modules/02-single-cell-tech.html#best-practices",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipRecommendations\n\n\n\n\nInclude appropriate biological replicates\nUse standardized protocols\nRecord detailed metadata\nImplement rigorous QC at each step\nUse established computational workflows\nValidate findings with orthogonal methods"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#practical-exercise",
    "href": "modules/02-single-cell-tech.html#practical-exercise",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\nExplore a published single-cell brain dataset:\n\nVisit the Allen Brain Map Single Cell Portal\nBrowse available brain datasets\nExamine cell type diversity in a region of interest\nCompare gene expression across cell types\nConsider: What biological questions could this data answer?"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#key-takeaways",
    "href": "modules/02-single-cell-tech.html#key-takeaways",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nSingle-cell RNA-seq reveals cellular heterogeneity invisible to bulk methods\nMultiple platforms exist with different trade-offs\n10x Genomics is the most widely used commercial platform\nBrain tissue presents unique challenges (cell size, fragility)\nCareful experimental design is crucial for success\nTechnology continues to evolve with multimodal approaches"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#additional-resources",
    "href": "modules/02-single-cell-tech.html#additional-resources",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nRecommended Readings\n\n“Single-cell RNA-seq: a primer” - Nature Methods\n“Best practices for single-cell analysis” - Molecular Systems Biology\n“Single-cell genomics in neuroscience” - Nature Reviews Neuroscience\n\n\n\nTutorials\n\n10x Genomics Support Documentation\nSeurat tutorials and vignettes\nScanpy tutorials for Python users"
  },
  {
    "objectID": "modules/02-single-cell-tech.html#next-module",
    "href": "modules/02-single-cell-tech.html#next-module",
    "title": "Module 2: Introduction to Single-Cell Technology",
    "section": "Next Module",
    "text": "Next Module\nNow that you understand single-cell technology, let’s build the computational skills needed to analyze this data!\nContinue to Module 3: Linux Command Line Fundamentals →\n\n\n\n\n\n\n\nNoteQuestions?\n\n\n\nReach out via the course discussion forum or during office hours listed on the Schedule page."
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html",
    "href": "modules/04-cellranger-pipeline.html",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "",
    "text": "CellRanger is the official 10x Genomics pipeline for processing single-cell RNA-seq data. This module covers installation, usage, and understanding CellRanger outputs.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand the CellRanger workflow\nInstall and configure CellRanger\nProcess raw BCL or FASTQ files\nInterpret CellRanger outputs and QC metrics\nAggregate multiple samples\nTroubleshoot common issues"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#overview",
    "href": "modules/04-cellranger-pipeline.html#overview",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "",
    "text": "CellRanger is the official 10x Genomics pipeline for processing single-cell RNA-seq data. This module covers installation, usage, and understanding CellRanger outputs.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand the CellRanger workflow\nInstall and configure CellRanger\nProcess raw BCL or FASTQ files\nInterpret CellRanger outputs and QC metrics\nAggregate multiple samples\nTroubleshoot common issues"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#what-is-cellranger",
    "href": "modules/04-cellranger-pipeline.html#what-is-cellranger",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "What is CellRanger?",
    "text": "What is CellRanger?\nCellRanger is a set of analysis pipelines that process Chromium single-cell data:\n\ncellranger mkfastq: Demultiplex raw base call files\ncellranger count: Align reads and generate gene-cell matrices\ncellranger aggr: Aggregate multiple samples\ncellranger reanalyze: Re-run analysis with different parameters\ncellranger vdj: Analyze V(D)J repertoires"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#installation",
    "href": "modules/04-cellranger-pipeline.html#installation",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Installation",
    "text": "Installation\n\nSystem Requirements\n\nLinux operating system\n8-core Intel or AMD processor\n64 GB RAM minimum\n1 TB free disk space\n\n\n\nDownload and Setup\n# Download CellRanger\ncurl -o cellranger-7.2.0.tar.gz \"https://cf.10xgenomics.com/releases/cell-exp/cellranger-7.2.0.tar.gz\"\n\n# Extract\ntar -xzvf cellranger-7.2.0.tar.gz\n\n# Add to PATH\nexport PATH=/path/to/cellranger-7.2.0:$PATH\n\n# Verify installation\ncellranger --version"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#reference-genome",
    "href": "modules/04-cellranger-pipeline.html#reference-genome",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Reference Genome",
    "text": "Reference Genome\n\nDownload Pre-built Reference\n# Human (GRCh38)\ncurl -O \"https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2024-A.tar.gz\"\ntar -xzvf refdata-gex-GRCh38-2024-A.tar.gz\n\n# Mouse (mm10)\ncurl -O \"https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2024-A.tar.gz\"\ntar -xzvf refdata-gex-mm10-2024-A.tar.gz"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#cellranger-count-workflow",
    "href": "modules/04-cellranger-pipeline.html#cellranger-count-workflow",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "CellRanger Count Workflow",
    "text": "CellRanger Count Workflow\n\nBasic Command\ncellranger count --id=sample_name \\\n                 --transcriptome=/path/to/refdata-gex-GRCh38-2024-A \\\n                 --fastqs=/path/to/fastq/folder \\\n                 --sample=sample_prefix \\\n                 --localcores=8 \\\n                 --localmem=64\n\n\nParameters Explained\n\n–id: Unique identifier for output folder\n–transcriptome: Path to reference transcriptome\n–fastqs: Directory containing FASTQ files\n–sample: Sample name matching FASTQ prefix\n–localcores: Number of CPU cores to use\n–localmem: Memory limit in GB"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#pipeline-steps",
    "href": "modules/04-cellranger-pipeline.html#pipeline-steps",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Pipeline Steps",
    "text": "Pipeline Steps\n\n1. FASTQ Generation (if needed)\ncellranger mkfastq --run=/path/to/sequencer/output \\\n                   --csv=sample_sheet.csv \\\n                   --output-dir=fastqs\n\n\n2. Alignment and Quantification\n\nCellRanger count performs:\n\nFASTQ read processing\nBarcode and UMI extraction\nRead alignment (STAR aligner)\nGene quantification\nCell calling (distinguish cells from background)\nUMI counting\nSecondary analysis (clustering, t-SNE)"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#understanding-outputs",
    "href": "modules/04-cellranger-pipeline.html#understanding-outputs",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Understanding Outputs",
    "text": "Understanding Outputs\n\nOutput Directory Structure\nsample_name/\n├── outs/\n│   ├── web_summary.html          # QC report\n│   ├── metrics_summary.csv       # Key metrics\n│   ├── filtered_feature_bc_matrix/   # Cell x gene matrix\n│   ├── raw_feature_bc_matrix/        # All barcodes\n│   ├── analysis/                 # Secondary analysis\n│   ├── molecule_info.h5         # Molecule-level info\n│   └── possorted_genome_bam.bam # Aligned reads\n\n\nKey Output Files\n\nEssential files:\n\nweb_summary.html: Interactive QC report\nfiltered_feature_bc_matrix: For downstream analysis\ncloupe.cloupe: For Loupe Browser visualization\nmetrics_summary.csv: Numerical QC metrics"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#quality-control-metrics",
    "href": "modules/04-cellranger-pipeline.html#quality-control-metrics",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Quality Control Metrics",
    "text": "Quality Control Metrics\n\nCell-Level Metrics\nEstimated Number of Cells\nMean Reads per Cell\nMedian Genes per Cell\nTotal Genes Detected\nMedian UMI Counts per Cell\n\n\nSequencing Metrics\nNumber of Reads\nValid Barcodes\nSequencing Saturation\nQ30 Bases in Barcode/UMI/Read\n\n\nMapping Metrics\nReads Mapped to Genome\nReads Mapped to Transcriptome\nReads Mapped Confidently to Transcriptome"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#interpreting-results",
    "href": "modules/04-cellranger-pipeline.html#interpreting-results",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Interpreting Results",
    "text": "Interpreting Results\n\nGood Quality Sample\n\n\n\n\n\n\nTipQuality Indicators\n\n\n\n\nSequencing saturation &gt; 50%\nQ30 &gt; 80% for all components\nValid barcodes &gt; 90%\nMedian genes per cell &gt; 500-1000\nMitochondrial % &lt; 5-10%\n\n\n\n\n\nCommon Issues\n\n\n\n\n\n\nImportantRed Flags\n\n\n\n\nLow cell recovery\nHigh mitochondrial content\nLow genes per cell\nLow sequencing saturation\nPoor mapping rate"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#aggregating-multiple-samples",
    "href": "modules/04-cellranger-pipeline.html#aggregating-multiple-samples",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Aggregating Multiple Samples",
    "text": "Aggregating Multiple Samples\n\nCreating Aggregation CSV\nlibrary_id,molecule_h5\nsample1,/path/to/sample1/outs/molecule_info.h5\nsample2,/path/to/sample2/outs/molecule_info.h5\nsample3,/path/to/sample3/outs/molecule_info.h5\n\n\nRunning Aggregation\ncellranger aggr --id=aggregated \\\n                --csv=aggregation.csv \\\n                --normalize=mapped"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#working-with-cellranger-outputs",
    "href": "modules/04-cellranger-pipeline.html#working-with-cellranger-outputs",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Working with CellRanger Outputs",
    "text": "Working with CellRanger Outputs\n\nLoading into Python (Scanpy)\nimport scanpy as sc\n\n# Load filtered matrix\nadata = sc.read_10x_mtx(\n    'sample_name/outs/filtered_feature_bc_matrix/',\n    var_names='gene_symbols',\n    cache=True\n)\n\n# View data\nprint(adata)\n\n\nLoading into R (Seurat)\nlibrary(Seurat)\n\n# Load data\ndata_dir &lt;- 'sample_name/outs/filtered_feature_bc_matrix/'\nseurat_obj &lt;- Read10X(data.dir = data_dir)\nseurat_obj &lt;- CreateSeuratObject(counts = seurat_obj)"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#advanced-options",
    "href": "modules/04-cellranger-pipeline.html#advanced-options",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Advanced Options",
    "text": "Advanced Options\n\nCell Calling Parameters\ncellranger count --id=sample \\\n                 --transcriptome=refdata \\\n                 --fastqs=fastqs \\\n                 --expect-cells=5000 \\\n                 --force-cells=3000\n\n\nNuclei Isolation\ncellranger count --id=sample \\\n                 --transcriptome=refdata \\\n                 --fastqs=fastqs \\\n                 --include-introns"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#troubleshooting",
    "href": "modules/04-cellranger-pipeline.html#troubleshooting",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nLow Cell Recovery\n\nCheck cell viability\nVerify loading concentration\nReview dissociation protocol\n\n\n\nHigh Mitochondrial Content\n\nIndicates cell stress\nCheck tissue handling\nConsider quality filtering\n\n\n\nLow Mapping Rate\n\nVerify correct reference genome\nCheck for contamination\nReview sequencing quality"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#practical-exercise",
    "href": "modules/04-cellranger-pipeline.html#practical-exercise",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nDownload tutorial dataset from 10x Genomics\nRun cellranger count\nExamine web_summary.html\nAssess data quality\nLoad matrix into Python/R"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#best-practices",
    "href": "modules/04-cellranger-pipeline.html#best-practices",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways save web_summary.html reports\nDocument CellRanger version used\nKeep raw FASTQ files backed up\nUse consistent file naming\nMonitor disk space during runs"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#key-takeaways",
    "href": "modules/04-cellranger-pipeline.html#key-takeaways",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nCellRanger processes raw 10x data to gene-cell matrices\nUnderstanding QC metrics is crucial\nMultiple samples can be aggregated\nOutputs are compatible with Scanpy/Seurat\nProper interpretation guides downstream analysis"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#additional-resources",
    "href": "modules/04-cellranger-pipeline.html#additional-resources",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Additional Resources",
    "text": "Additional Resources\n\n10x Genomics Support\nCellRanger Documentation\nCellRanger Algorithms"
  },
  {
    "objectID": "modules/04-cellranger-pipeline.html#next-module",
    "href": "modules/04-cellranger-pipeline.html#next-module",
    "title": "Module 4: CellRanger Pipeline for Single-Cell Analysis",
    "section": "Next Module",
    "text": "Next Module\nNow that you can process raw data, let’s learn Python for downstream analysis!\nContinue to Module 5: Fundamentals of Python Part 1 →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/06-python-part2.html",
    "href": "modules/06-python-part2.html",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "",
    "text": "Building on Python fundamentals, this module covers NumPy, Pandas, and data visualization—essential tools for bioinformatics analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nMaster NumPy for numerical computing\nUse Pandas for data manipulation\nCreate visualizations with Matplotlib and Seaborn\nWork with biological data formats\nOptimize code performance"
  },
  {
    "objectID": "modules/06-python-part2.html#overview",
    "href": "modules/06-python-part2.html#overview",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "",
    "text": "Building on Python fundamentals, this module covers NumPy, Pandas, and data visualization—essential tools for bioinformatics analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nMaster NumPy for numerical computing\nUse Pandas for data manipulation\nCreate visualizations with Matplotlib and Seaborn\nWork with biological data formats\nOptimize code performance"
  },
  {
    "objectID": "modules/06-python-part2.html#numpy-numerical-python",
    "href": "modules/06-python-part2.html#numpy-numerical-python",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "NumPy: Numerical Python",
    "text": "NumPy: Numerical Python\n\nArray Creation\nimport numpy as np\n\n# Create arrays\narr = np.array([1, 2, 3, 4, 5])\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Special arrays\nzeros = np.zeros((3, 3))\nones = np.ones((2, 4))\nidentity = np.eye(3)\nrandom = np.random.rand(3, 3)\n\n\nArray Operations\n# Arithmetic\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = a + b\nd = a * b\ne = a ** 2\n\n# Matrix operations\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nC = np.dot(A, B)  # Matrix multiplication\n\n\nStatistical Operations\ndata = np.random.randn(1000)\n\nmean = np.mean(data)\nmedian = np.median(data)\nstd = np.std(data)\nvar = np.var(data)\nminimum = np.min(data)\nmaximum = np.max(data)"
  },
  {
    "objectID": "modules/06-python-part2.html#pandas-data-analysis",
    "href": "modules/06-python-part2.html#pandas-data-analysis",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Pandas: Data Analysis",
    "text": "Pandas: Data Analysis\n\nDataFrames\nimport pandas as pd\n\n# Create DataFrame\ndata = {\n    'gene': ['BDNF', 'SYN1', 'GFAP'],\n    'expression': [100, 150, 75],\n    'cell_type': ['neuron', 'neuron', 'astrocyte']\n}\ndf = pd.DataFrame(data)\n\n# Read from file\ndf = pd.read_csv('data.csv')\ndf = pd.read_excel('data.xlsx')\ndf = pd.read_table('data.tsv', sep='\\t')\n\n\nData Exploration\n# View data\nprint(df.head())\nprint(df.tail())\nprint(df.info())\nprint(df.describe())\n\n# Dimensions\nrows, cols = df.shape\n\n# Column names\ncolumns = df.columns\n\n# Data types\ndtypes = df.dtypes\n\n\nData Selection\n# Select columns\ngenes = df['gene']\nsubset = df[['gene', 'expression']]\n\n# Select rows\nfirst_row = df.iloc[0]\nslice_rows = df.iloc[0:5]\n\n# Conditional selection\nhigh_expr = df[df['expression'] &gt; 100]\nneurons = df[df['cell_type'] == 'neuron']\n\n# Query\nresult = df.query('expression &gt; 100 and cell_type == \"neuron\"')\n\n\nData Manipulation\n# Add column\ndf['log_expression'] = np.log2(df['expression'] + 1)\n\n# Remove column\ndf = df.drop('old_column', axis=1)\n\n# Rename columns\ndf = df.rename(columns={'old_name': 'new_name'})\n\n# Sort\ndf_sorted = df.sort_values('expression', ascending=False)\n\n# Group by\ngrouped = df.groupby('cell_type')['expression'].mean()\n\n# Merge DataFrames\nmerged = pd.merge(df1, df2, on='gene')"
  },
  {
    "objectID": "modules/06-python-part2.html#data-visualization",
    "href": "modules/06-python-part2.html#data-visualization",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Data Visualization",
    "text": "Data Visualization\n\nMatplotlib Basics\nimport matplotlib.pyplot as plt\n\n# Line plot\nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.title('Simple Plot')\nplt.show()\n\n# Scatter plot\nx = np.random.randn(100)\ny = np.random.randn(100)\nplt.scatter(x, y, alpha=0.5)\nplt.show()\n\n# Histogram\ndata = np.random.randn(1000)\nplt.hist(data, bins=30)\nplt.show()\n\n# Multiple subplots\nfig, axes = plt.subplots(2, 2, figsize=(10, 8))\naxes[0, 0].plot(x, y)\naxes[0, 1].hist(data)\nplt.tight_layout()\nplt.show()\n\n\nSeaborn for Statistical Plots\nimport seaborn as sns\n\n# Set style\nsns.set_style('whitegrid')\n\n# Distribution plot\nsns.histplot(data, kde=True)\n\n# Box plot\nsns.boxplot(x='cell_type', y='expression', data=df)\n\n# Violin plot\nsns.violinplot(x='cell_type', y='expression', data=df)\n\n# Heatmap\ncorr = df.corr()\nsns.heatmap(corr, annot=True, cmap='coolwarm')\n\n# Pair plot\nsns.pairplot(df, hue='cell_type')"
  },
  {
    "objectID": "modules/06-python-part2.html#working-with-biological-data",
    "href": "modules/06-python-part2.html#working-with-biological-data",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Working with Biological Data",
    "text": "Working with Biological Data\n\nProcessing Gene Expression Data\n# Load expression matrix\nexpr = pd.read_csv('expression_matrix.csv', index_col=0)\n\n# Log transformation\nexpr_log = np.log2(expr + 1)\n\n# Normalization\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nexpr_scaled = scaler.fit_transform(expr)\n\n# Filter low-expressed genes\nexpr_filtered = expr[expr.mean(axis=1) &gt; 10]\n\n# Calculate correlations\ngene_corr = expr.T.corr()\n\n\nSequence Analysis\ndef gc_content(sequence):\n    \"\"\"Calculate GC content of DNA sequence.\"\"\"\n    gc = sequence.count('G') + sequence.count('C')\n    return gc / len(sequence) * 100\n\ndef reverse_complement(sequence):\n    \"\"\"Return reverse complement of DNA sequence.\"\"\"\n    complement = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}\n    rev_comp = ''.join(complement[base] for base in reversed(sequence))\n    return rev_comp\n\n# Count k-mers\ndef count_kmers(sequence, k):\n    \"\"\"Count k-mers in sequence.\"\"\"\n    kmers = {}\n    for i in range(len(sequence) - k + 1):\n        kmer = sequence[i:i+k]\n        kmers[kmer] = kmers.get(kmer, 0) + 1\n    return kmers"
  },
  {
    "objectID": "modules/06-python-part2.html#performance-optimization",
    "href": "modules/06-python-part2.html#performance-optimization",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Performance Optimization",
    "text": "Performance Optimization\n\nVectorization\n# Slow: Loop\nresult = []\nfor x in data:\n    result.append(x ** 2)\n\n# Fast: Vectorized\nresult = data ** 2\n\n# Pandas apply\ndf['log_expr'] = df['expression'].apply(np.log2)\n\n# Vectorized alternative\ndf['log_expr'] = np.log2(df['expression'])\n\n\nMemory Efficiency\n# Check memory usage\ndf.memory_usage()\n\n# Optimize dtypes\ndf['category_col'] = df['category_col'].astype('category')\n\n# Use chunks for large files\nfor chunk in pd.read_csv('large_file.csv', chunksize=10000):\n    process(chunk)"
  },
  {
    "objectID": "modules/06-python-part2.html#practical-applications",
    "href": "modules/06-python-part2.html#practical-applications",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Practical Applications",
    "text": "Practical Applications\n\nSingle-Cell Data Processing\nimport scanpy as sc\n\n# Load data\nadata = sc.read_10x_mtx('filtered_matrix/')\n\n# Basic QC\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=3)\n\n# Calculate QC metrics\nadata.var['mt'] = adata.var_names.str.startswith('MT-')\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], inplace=True)\n\n# Visualize\nsc.pl.violin(adata, ['n_genes_by_counts', 'total_counts'])"
  },
  {
    "objectID": "modules/06-python-part2.html#practical-exercises",
    "href": "modules/06-python-part2.html#practical-exercises",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Practical Exercises",
    "text": "Practical Exercises\n\n\n\n\n\n\nImportantHands-On Practice\n\n\n\n\nLoad and explore a gene expression dataset\nCalculate summary statistics\nFilter genes and samples\nCreate publication-quality plots\nPerform correlation analysis"
  },
  {
    "objectID": "modules/06-python-part2.html#key-takeaways",
    "href": "modules/06-python-part2.html#key-takeaways",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy provides efficient numerical operations\nPandas excels at data manipulation\nMatplotlib and Seaborn create visualizations\nVectorization improves performance\nThese tools are essential for bioinformatics"
  },
  {
    "objectID": "modules/06-python-part2.html#additional-resources",
    "href": "modules/06-python-part2.html#additional-resources",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nNumPy Documentation\nPandas Documentation\nMatplotlib Gallery\nSeaborn Tutorial"
  },
  {
    "objectID": "modules/06-python-part2.html#next-module",
    "href": "modules/06-python-part2.html#next-module",
    "title": "Module 6: Fundamentals of Python - Part 2",
    "section": "Next Module",
    "text": "Next Module\nNow that you have Python skills, let’s apply them to quality control!\nContinue to Module 7: Quality Control →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html",
    "href": "modules/08-dimensionality-reduction.html",
    "title": "Module 8: Dimensionality Reduction",
    "section": "",
    "text": "Single-cell data is high-dimensional. Dimensionality reduction techniques enable visualization and downstream analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand curse of dimensionality\nApply PCA for linear dimensionality reduction\nUse t-SNE and UMAP for non-linear visualization\nInterpret dimensionality reduction plots\nChoose appropriate parameters"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#overview",
    "href": "modules/08-dimensionality-reduction.html#overview",
    "title": "Module 8: Dimensionality Reduction",
    "section": "",
    "text": "Single-cell data is high-dimensional. Dimensionality reduction techniques enable visualization and downstream analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand curse of dimensionality\nApply PCA for linear dimensionality reduction\nUse t-SNE and UMAP for non-linear visualization\nInterpret dimensionality reduction plots\nChoose appropriate parameters"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#the-curse-of-dimensionality",
    "href": "modules/08-dimensionality-reduction.html#the-curse-of-dimensionality",
    "title": "Module 8: Dimensionality Reduction",
    "section": "The Curse of Dimensionality",
    "text": "The Curse of Dimensionality\nSingle-cell datasets have: - 10,000+ genes (dimensions) - 1,000-100,000+ cells - Sparse, high-dimensional space\nChallenge: Impossible to visualize directly\nSolution: Reduce to 2-3 dimensions while preserving structure"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#principal-component-analysis-pca",
    "href": "modules/08-dimensionality-reduction.html#principal-component-analysis-pca",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Principal Component Analysis (PCA)",
    "text": "Principal Component Analysis (PCA)\n\nWhat is PCA?\n\nLinear dimensionality reduction\nFinds directions of maximum variance\nCreates orthogonal principal components\nFoundation for many downstream analyses\n\n\n\nRunning PCA\nimport scanpy as sc\n\n# Normalize and log-transform\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\n\n# Identify highly variable genes\nsc.pp.highly_variable_genes(adata, n_top_genes=2000)\n\n# Scale data\nsc.pp.scale(adata, max_value=10)\n\n# Run PCA\nsc.tl.pca(adata, svd_solver='arpack')\n\n# Visualize\nsc.pl.pca(adata, color='cell_type')\nsc.pl.pca_variance_ratio(adata, log=True, n_pcs=50)\n\n\nChoosing Number of PCs\n# Elbow plot\nsc.pl.pca_variance_ratio(adata, n_pcs=50)\n\n# Typically use 30-50 PCs for downstream analysis"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#t-sne-t-distributed-stochastic-neighbor-embedding",
    "href": "modules/08-dimensionality-reduction.html#t-sne-t-distributed-stochastic-neighbor-embedding",
    "title": "Module 8: Dimensionality Reduction",
    "section": "t-SNE (t-Distributed Stochastic Neighbor Embedding)",
    "text": "t-SNE (t-Distributed Stochastic Neighbor Embedding)\n\nCharacteristics\n\nNon-linear dimensionality reduction\nPreserves local structure\nGood for visualization\nStochastic (different runs produce different results)\n\n\n\nRunning t-SNE\n# Compute t-SNE\nsc.tl.tsne(adata, n_pcs=30, perplexity=30)\n\n# Visualize\nsc.pl.tsne(adata, color=['cell_type', 'n_genes', 'pct_counts_mt'])\n\n\nPerplexity Parameter\n# Try different perplexities\nfor perp in [5, 30, 50, 100]:\n    sc.tl.tsne(adata, n_pcs=30, perplexity=perp)\n    sc.pl.tsne(adata, color='cell_type', title=f'Perplexity={perp}')\nPerplexity: Balance between local and global structure - Low (5-15): Emphasizes local structure - High (30-100): Emphasizes global structure"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#umap-uniform-manifold-approximation-and-projection",
    "href": "modules/08-dimensionality-reduction.html#umap-uniform-manifold-approximation-and-projection",
    "title": "Module 8: Dimensionality Reduction",
    "section": "UMAP (Uniform Manifold Approximation and Projection)",
    "text": "UMAP (Uniform Manifold Approximation and Projection)\n\nAdvantages over t-SNE\n\nFaster computation\nBetter preserves global structure\nMore reproducible\nCan learn from supervised labels\n\n\n\nRunning UMAP\n# Compute neighbors\nsc.pp.neighbors(adata, n_neighbors=15, n_pcs=30)\n\n# Compute UMAP\nsc.tl.umap(adata)\n\n# Visualize\nsc.pl.umap(adata, color=['cell_type', 'n_genes', 'sample'])\n\n\nKey Parameters\n# min_dist: Controls how tightly points cluster\nsc.tl.umap(adata, min_dist=0.1)  # Tighter clusters\nsc.tl.umap(adata, min_dist=0.5)  # Looser clusters\n\n# n_neighbors: Balance local vs global\nsc.tl.umap(adata, n_neighbors=5)   # Local structure\nsc.tl.umap(adata, n_neighbors=50)  # Global structure"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#comparison-pca-vs-t-sne-vs-umap",
    "href": "modules/08-dimensionality-reduction.html#comparison-pca-vs-t-sne-vs-umap",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Comparison: PCA vs t-SNE vs UMAP",
    "text": "Comparison: PCA vs t-SNE vs UMAP\n\n\n\nFeature\nPCA\nt-SNE\nUMAP\n\n\n\n\nSpeed\nFast\nSlow\nFast\n\n\nGlobal structure\nYes\nNo\nPartial\n\n\nLocal structure\nNo\nYes\nYes\n\n\nDeterministic\nYes\nNo\nMostly\n\n\nInterpretable\nYes\nNo\nNo"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#visualizing-multiple-features",
    "href": "modules/08-dimensionality-reduction.html#visualizing-multiple-features",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Visualizing Multiple Features",
    "text": "Visualizing Multiple Features\n# Plot multiple genes\ngenes = ['BDNF', 'SYN1', 'GFAP', 'MBP']\nsc.pl.umap(adata, color=genes, cmap='viridis')\n\n# Plot QC metrics\nsc.pl.umap(adata, color=['n_genes', 'total_counts', 'pct_counts_mt'])\n\n# Plot categorical variables\nsc.pl.umap(adata, color=['sample', 'phase', 'cluster'])"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#feature-plots-gene-expression",
    "href": "modules/08-dimensionality-reduction.html#feature-plots-gene-expression",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Feature Plots (Gene Expression)",
    "text": "Feature Plots (Gene Expression)\n# Single gene\nsc.pl.umap(adata, color='BDNF', use_raw=False, cmap='Reds')\n\n# Multiple genes\nsc.pl.umap(adata, color=['BDNF', 'SYN1', 'GFAP', 'MBP'],\n           ncols=2, cmap='viridis')\n\n# With size scaling\nsc.pl.umap(adata, color='BDNF', size=50, alpha=0.8)"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#density-plots",
    "href": "modules/08-dimensionality-reduction.html#density-plots",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Density Plots",
    "text": "Density Plots\n# Cell density\nsc.tl.embedding_density(adata, basis='umap', groupby='cell_type')\nsc.pl.embedding_density(adata, basis='umap', key='umap_density_cell_type')"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#d-visualizations",
    "href": "modules/08-dimensionality-reduction.html#d-visualizations",
    "title": "Module 8: Dimensionality Reduction",
    "section": "3D Visualizations",
    "text": "3D Visualizations\n# 3D UMAP\nsc.tl.umap(adata, n_components=3)\nsc.pl.umap(adata, color='cell_type', projection='3d')"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#batch-effect-visualization",
    "href": "modules/08-dimensionality-reduction.html#batch-effect-visualization",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Batch Effect Visualization",
    "text": "Batch Effect Visualization\n# Check for batch effects\nsc.pl.umap(adata, color='batch')\n\n# Before and after correction\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nsc.pl.umap(adata_uncorrected, color='batch', ax=ax1, show=False, title='Before')\nsc.pl.umap(adata_corrected, color='batch', ax=ax2, show=False, title='After')\nplt.tight_layout()"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#practical-tips",
    "href": "modules/08-dimensionality-reduction.html#practical-tips",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Practical Tips",
    "text": "Practical Tips\n\n\n\n\n\n\nTipBest Practices\n\n\n\n\nAlways start with PCA\nUse 30-50 PCs for downstream analysis\nUMAP is generally preferred over t-SNE\nTry different parameter settings\nDon’t over-interpret distances\nValidate findings with gene expression\nUse multiple visualization methods"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#common-pitfalls",
    "href": "modules/08-dimensionality-reduction.html#common-pitfalls",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nOver-interpreting t-SNE/UMAP distances\nUsing too few highly variable genes\nNot scaling data before PCA\nIgnoring batch effects\nUsing inappropriate color scales"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#interpreting-results",
    "href": "modules/08-dimensionality-reduction.html#interpreting-results",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Interpreting Results",
    "text": "Interpreting Results\n\nGood Clustering\n\nClear separation of known cell types\nConsistent with marker gene expression\nReproducible across parameters\n\n\n\nRed Flags\n\nCells separated by technical factors (batch, QC metrics)\nNo separation of known cell types\nResults highly sensitive to parameters"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#practical-exercise",
    "href": "modules/08-dimensionality-reduction.html#practical-exercise",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nPreprocess your data (normalize, identify HVGs)\nRun PCA and examine variance explained\nCompute t-SNE with different perplexities\nCompute UMAP with different parameters\nVisualize known marker genes\nCompare and interpret results"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#key-takeaways",
    "href": "modules/08-dimensionality-reduction.html#key-takeaways",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nDimensionality reduction enables visualization\nPCA provides interpretable, linear reduction\nUMAP is preferred for visualization\nParameters matter—explore different settings\nAlways validate with biological knowledge\nDistances in 2D plots can be misleading"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#additional-resources",
    "href": "modules/08-dimensionality-reduction.html#additional-resources",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nUnderstanding UMAP\nHow to Use t-SNE Effectively\nScanpy UMAP Tutorial"
  },
  {
    "objectID": "modules/08-dimensionality-reduction.html#next-module",
    "href": "modules/08-dimensionality-reduction.html#next-module",
    "title": "Module 8: Dimensionality Reduction",
    "section": "Next Module",
    "text": "Next Module\nWith visualizations ready, let’s integrate multiple datasets!\nContinue to Module 9: Data Integration →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/10-clustering.html",
    "href": "modules/10-clustering.html",
    "title": "Module 10: Clustering",
    "section": "",
    "text": "Clustering groups similar cells together to identify cell types and states in single-cell datasets.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand clustering algorithms\nApply Leiden and Louvain clustering\nOptimize clustering resolution\nValidate and interpret clusters\nVisualize clustering results"
  },
  {
    "objectID": "modules/10-clustering.html#overview",
    "href": "modules/10-clustering.html#overview",
    "title": "Module 10: Clustering",
    "section": "",
    "text": "Clustering groups similar cells together to identify cell types and states in single-cell datasets.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand clustering algorithms\nApply Leiden and Louvain clustering\nOptimize clustering resolution\nValidate and interpret clusters\nVisualize clustering results"
  },
  {
    "objectID": "modules/10-clustering.html#why-clustering",
    "href": "modules/10-clustering.html#why-clustering",
    "title": "Module 10: Clustering",
    "section": "Why Clustering?",
    "text": "Why Clustering?\nGoals: - Identify cell types/subtypes - Discover novel populations - Group cells for downstream analyses - Enable cell type annotation"
  },
  {
    "objectID": "modules/10-clustering.html#graph-based-clustering",
    "href": "modules/10-clustering.html#graph-based-clustering",
    "title": "Module 10: Clustering",
    "section": "Graph-Based Clustering",
    "text": "Graph-Based Clustering\nMost common approach in scRNA-seq:\n\nBuild k-nearest neighbor (KNN) graph\nApply community detection algorithm\nAssign cells to clusters"
  },
  {
    "objectID": "modules/10-clustering.html#computing-neighbors",
    "href": "modules/10-clustering.html#computing-neighbors",
    "title": "Module 10: Clustering",
    "section": "Computing Neighbors",
    "text": "Computing Neighbors\nimport scanpy as sc\n\n# Compute neighborhood graph\nsc.pp.neighbors(\n    adata,\n    n_neighbors=15,   # Number of neighbors\n    n_pcs=30,         # Number of PCs to use\n    metric='euclidean' # Distance metric\n)"
  },
  {
    "objectID": "modules/10-clustering.html#leiden-clustering-recommended",
    "href": "modules/10-clustering.html#leiden-clustering-recommended",
    "title": "Module 10: Clustering",
    "section": "Leiden Clustering (Recommended)",
    "text": "Leiden Clustering (Recommended)\n# Run Leiden\nsc.tl.leiden(\n    adata,\n    resolution=0.5,    # Controls granularity\n    key_added='leiden'\n)\n\n# Visualize\nsc.pl.umap(adata, color='leiden')\n\nResolution Parameter\n# Low resolution: Fewer, larger clusters\nsc.tl.leiden(adata, resolution=0.2, key_added='leiden_02')\n\n# Medium resolution: Balanced\nsc.tl.leiden(adata, resolution=0.5, key_added='leiden_05')\n\n# High resolution: More, smaller clusters\nsc.tl.leiden(adata, resolution=1.0, key_added='leiden_10')\n\n# Compare\nsc.pl.umap(adata, color=['leiden_02', 'leiden_05', 'leiden_10'])"
  },
  {
    "objectID": "modules/10-clustering.html#louvain-clustering",
    "href": "modules/10-clustering.html#louvain-clustering",
    "title": "Module 10: Clustering",
    "section": "Louvain Clustering",
    "text": "Louvain Clustering\n# Run Louvain\nsc.tl.louvain(\n    adata,\n    resolution=0.5,\n    key_added='louvain'\n)\n\n# Visualize\nsc.pl.umap(adata, color='louvain')"
  },
  {
    "objectID": "modules/10-clustering.html#choosing-resolution",
    "href": "modules/10-clustering.html#choosing-resolution",
    "title": "Module 10: Clustering",
    "section": "Choosing Resolution",
    "text": "Choosing Resolution\n\nMethods to Determine Resolution\n\nBiological knowledge: Expected cell types\nStability: Consistent across resolutions\nMarker gene expression: Clear differential expression\nClustering metrics: Silhouette score, Davies-Bouldin\n\n\n\nResolution Sweep\n# Test multiple resolutions\nresolutions = [0.1, 0.3, 0.5, 0.7, 0.9, 1.1]\n\nfor res in resolutions:\n    sc.tl.leiden(adata, resolution=res, key_added=f'leiden_{res}')\n\n# Visualize all\nsc.pl.umap(adata, color=[f'leiden_{res}' for res in resolutions])"
  },
  {
    "objectID": "modules/10-clustering.html#hierarchical-clustering",
    "href": "modules/10-clustering.html#hierarchical-clustering",
    "title": "Module 10: Clustering",
    "section": "Hierarchical Clustering",
    "text": "Hierarchical Clustering\n# For smaller datasets or subclustering\nfrom scipy.cluster.hierarchy import dendrogram, linkage\n\n# Compute linkage\nZ = linkage(adata.obsm['X_pca'][:, :30], method='ward')\n\n# Plot dendrogram\nplt.figure(figsize=(10, 5))\ndendrogram(Z)\nplt.show()"
  },
  {
    "objectID": "modules/10-clustering.html#validating-clusters",
    "href": "modules/10-clustering.html#validating-clusters",
    "title": "Module 10: Clustering",
    "section": "Validating Clusters",
    "text": "Validating Clusters\n\nMarker Gene Expression\n# Known cell type markers\nmarkers = {\n    'Neurons': ['SYN1', 'SNAP25', 'RBFOX3'],\n    'Astrocytes': ['GFAP', 'AQP4', 'SLC1A3'],\n    'Oligodendrocytes': ['MBP', 'MOG', 'PLP1'],\n    'Microglia': ['CX3CR1', 'P2RY12', 'TMEM119']\n}\n\n# Visualize markers\nfor cell_type, genes in markers.items():\n    sc.pl.umap(adata, color=genes, ncols=3, title=cell_type)\n\n\nCluster Stability\n# Subsample and re-cluster\nimport numpy as np\n\nn_iterations = 10\nstability_scores = []\n\nfor i in range(n_iterations):\n    # Subsample 80% of cells\n    sample_idx = np.random.choice(adata.n_obs,\n                                   int(0.8 * adata.n_obs),\n                                   replace=False)\n    adata_sub = adata[sample_idx, :]\n\n    # Cluster\n    sc.pp.neighbors(adata_sub)\n    sc.tl.leiden(adata_sub)\n\n    # Calculate stability metric\n    # (compare to original clustering)\n\n\nSilhouette Score\nfrom sklearn.metrics import silhouette_score\n\n# Calculate silhouette score\nsilhouette = silhouette_score(\n    adata.obsm['X_pca'][:, :30],\n    adata.obs['leiden']\n)\n\nprint(f\"Silhouette score: {silhouette:.3f}\")\n# Higher is better (range: -1 to 1)"
  },
  {
    "objectID": "modules/10-clustering.html#finding-cluster-markers",
    "href": "modules/10-clustering.html#finding-cluster-markers",
    "title": "Module 10: Clustering",
    "section": "Finding Cluster Markers",
    "text": "Finding Cluster Markers\n\nDifferential Expression\n# Find markers for each cluster\nsc.tl.rank_genes_groups(\n    adata,\n    groupby='leiden',\n    method='wilcoxon',\n    key_added='rank_genes_leiden'\n)\n\n# Visualize top markers\nsc.pl.rank_genes_groups(adata, n_genes=20)\n\n# Heatmap of top markers\nsc.pl.rank_genes_groups_heatmap(adata, n_genes=10)\n\n# Dotplot\nsc.pl.rank_genes_groups_dotplot(adata, n_genes=5)\n\n\nExtract Marker Genes\n# Get marker DataFrame\nresult = sc.get.rank_genes_groups_df(adata, group='0')\nprint(result.head(20))\n\n# Filter significant markers\nmarkers = result[\n    (result['pvals_adj'] &lt; 0.05) &\n    (result['logfoldchanges'] &gt; 1)\n]"
  },
  {
    "objectID": "modules/10-clustering.html#visualizing-clusters",
    "href": "modules/10-clustering.html#visualizing-clusters",
    "title": "Module 10: Clustering",
    "section": "Visualizing Clusters",
    "text": "Visualizing Clusters\n\nUMAP with Clusters\n# Basic clustering plot\nsc.pl.umap(adata, color='leiden', legend_loc='on data')\n\n# With multiple features\nsc.pl.umap(adata, color=['leiden', 'n_genes', 'cell_type'])\n\n# Faceted by cluster\nsc.pl.umap(adata, color='leiden', ncols=1, groups=['0', '1', '2'])\n\n\nDot Plot\n# Marker gene expression per cluster\nmarker_genes = ['BDNF', 'SYN1', 'GFAP', 'MBP', 'CX3CR1']\n\nsc.pl.dotplot(adata,\n              marker_genes,\n              groupby='leiden',\n              dendrogram=True)\n\n\nMatrix Plot\nsc.pl.matrixplot(adata,\n                 marker_genes,\n                 groupby='leiden',\n                 dendrogram=True,\n                 cmap='RdBu_r')\n\n\nStacked Violin Plot\nsc.pl.stacked_violin(adata,\n                     marker_genes,\n                     groupby='leiden',\n                     rotation=90)"
  },
  {
    "objectID": "modules/10-clustering.html#subclustering",
    "href": "modules/10-clustering.html#subclustering",
    "title": "Module 10: Clustering",
    "section": "Subclustering",
    "text": "Subclustering\n# Subset specific cluster\ncluster_2 = adata[adata.obs['leiden'] == '2'].copy()\n\n# Re-process\nsc.pp.neighbors(cluster_2, n_pcs=20)\nsc.tl.leiden(cluster_2, resolution=0.5)\nsc.tl.umap(cluster_2)\n\n# Visualize subclusters\nsc.pl.umap(cluster_2, color='leiden')"
  },
  {
    "objectID": "modules/10-clustering.html#cluster-annotation",
    "href": "modules/10-clustering.html#cluster-annotation",
    "title": "Module 10: Clustering",
    "section": "Cluster Annotation",
    "text": "Cluster Annotation\n\nManual Annotation\n# Based on marker gene expression\ncluster_names = {\n    '0': 'Excitatory neurons',\n    '1': 'Inhibitory neurons',\n    '2': 'Astrocytes',\n    '3': 'Oligodendrocytes',\n    '4': 'Microglia',\n    '5': 'OPCs'\n}\n\nadata.obs['cell_type'] = adata.obs['leiden'].map(cluster_names)\n\n# Visualize\nsc.pl.umap(adata, color='cell_type')"
  },
  {
    "objectID": "modules/10-clustering.html#common-issues",
    "href": "modules/10-clustering.html#common-issues",
    "title": "Module 10: Clustering",
    "section": "Common Issues",
    "text": "Common Issues\n\nOver-clustering\nSymptoms: Too many similar clusters\nSolutions: - Decrease resolution - Filter highly variable genes more strictly - Check for doublets\n\n\nUnder-clustering\nSymptoms: Mixed cell types in clusters\nSolutions: - Increase resolution - Use more PCs - Re-examine preprocessing\n\n\nBatch-Driven Clustering\nSymptoms: Clusters separate by batch, not biology\nSolutions: - Apply data integration - Use batch-aware methods"
  },
  {
    "objectID": "modules/10-clustering.html#best-practices",
    "href": "modules/10-clustering.html#best-practices",
    "title": "Module 10: Clustering",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipClustering Tips\n\n\n\n\nTry multiple resolutions\nValidate with known markers\nCalculate stability metrics\nCompare Leiden and Louvain\nSubcluster for finer resolution\nDocument decisions\nUse biological knowledge"
  },
  {
    "objectID": "modules/10-clustering.html#practical-exercise",
    "href": "modules/10-clustering.html#practical-exercise",
    "title": "Module 10: Clustering",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nCompute neighbor graph with different parameters\nRun Leiden clustering at multiple resolutions\nVisualize clusters with UMAP\nFind marker genes for each cluster\nValidate clusters with known markers\nChoose optimal resolution\nAnnotate clusters based on markers"
  },
  {
    "objectID": "modules/10-clustering.html#key-takeaways",
    "href": "modules/10-clustering.html#key-takeaways",
    "title": "Module 10: Clustering",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nGraph-based clustering is standard in scRNA-seq\nLeiden is generally preferred over Louvain\nResolution parameter controls granularity\nAlways validate with marker genes\nClustering is iterative, not one-size-fits-all\nBiological interpretation is essential"
  },
  {
    "objectID": "modules/10-clustering.html#additional-resources",
    "href": "modules/10-clustering.html#additional-resources",
    "title": "Module 10: Clustering",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nLeiden Algorithm Paper\nClustering Best Practices\nScanpy Clustering Tutorial"
  },
  {
    "objectID": "modules/10-clustering.html#next-module",
    "href": "modules/10-clustering.html#next-module",
    "title": "Module 10: Clustering",
    "section": "Next Module",
    "text": "Next Module\nWith clusters defined, let’s find differentially expressed genes!\nContinue to Module 11: Differential Expression →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/12-celltype-prediction.html",
    "href": "modules/12-celltype-prediction.html",
    "title": "Module 12: Cell Type Prediction",
    "section": "",
    "text": "Automated cell type annotation transfers labels from well-annotated reference datasets to query datasets, enabling consistent and scalable analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand reference-based annotation\nUse tools like CellTypist, scANVI, and Azimuth\nEvaluate annotation quality\nHandle ambiguous annotations\nCreate custom reference datasets"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#overview",
    "href": "modules/12-celltype-prediction.html#overview",
    "title": "Module 12: Cell Type Prediction",
    "section": "",
    "text": "Automated cell type annotation transfers labels from well-annotated reference datasets to query datasets, enabling consistent and scalable analysis.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand reference-based annotation\nUse tools like CellTypist, scANVI, and Azimuth\nEvaluate annotation quality\nHandle ambiguous annotations\nCreate custom reference datasets"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#why-automated-annotation",
    "href": "modules/12-celltype-prediction.html#why-automated-annotation",
    "title": "Module 12: Cell Type Prediction",
    "section": "Why Automated Annotation?",
    "text": "Why Automated Annotation?\nChallenges of manual annotation: - Time-consuming - Subjective - Inconsistent across studies - Requires extensive domain knowledge\nBenefits of automated methods: - Fast and scalable - Consistent and reproducible - Leverage existing knowledge - Handle large datasets"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#annotation-strategies",
    "href": "modules/12-celltype-prediction.html#annotation-strategies",
    "title": "Module 12: Cell Type Prediction",
    "section": "Annotation Strategies",
    "text": "Annotation Strategies\n\n1. Marker-Based (Simple)\nimport scanpy as sc\n\n# Define marker genes\nmarkers = {\n    'Neurons': ['SYN1', 'SNAP25', 'RBFOX3'],\n    'Astrocytes': ['GFAP', 'AQP4', 'SLC1A3'],\n    'Oligodendrocytes': ['MBP', 'MOG', 'PLP1']\n}\n\n# Score cells for each type\nfor cell_type, genes in markers.items():\n    sc.tl.score_genes(adata, genes, score_name=f'{cell_type}_score')\n\n# Assign based on highest score\nscores = [f'{ct}_score' for ct in markers.keys()]\nadata.obs['cell_type'] = adata.obs[scores].idxmax(axis=1)\n\n\n2. Reference-Based Transfer\nMost sophisticated approach using machine learning."
  },
  {
    "objectID": "modules/12-celltype-prediction.html#celltypist",
    "href": "modules/12-celltype-prediction.html#celltypist",
    "title": "Module 12: Cell Type Prediction",
    "section": "CellTypist",
    "text": "CellTypist\n\nInstallation\npip install celltypist\n\n\nBasic Usage\nimport celltypist\nfrom celltypist import models\n\n# Download model\nmodels.download_models(model='Immune_All_Low.pkl')\n\n# Load model\nmodel = models.Model.load(model='Immune_All_Low.pkl')\n\n# Predict\npredictions = celltypist.annotate(\n    adata,\n    model='Immune_All_Low.pkl',\n    majority_voting=True\n)\n\n# Get annotated object\nadata_predicted = predictions.to_adata()\n\n# View predictions\nprint(adata_predicted.obs[['predicted_labels', 'conf_score']])\n\n# Visualize\nsc.pl.umap(adata_predicted, color=['predicted_labels', 'conf_score'])\n\n\nAvailable Models\n# List available models\nmodels.models_description()\n\n# Brain-specific models\n# - 'Developing_Human_Brain.pkl'\n# - 'Adult_Mouse_Brain.pkl'\n\n\nCustom Training\n# Train custom model\nfrom celltypist import train\n\n# Prepare training data\nnew_model = train(\n    adata_reference,\n    labels='cell_type',\n    n_jobs=10,\n    feature_selection=True\n)\n\n# Save model\nnew_model.write('my_custom_model.pkl')"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#scanvi-single-cell-annotation-using-variational-inference",
    "href": "modules/12-celltype-prediction.html#scanvi-single-cell-annotation-using-variational-inference",
    "title": "Module 12: Cell Type Prediction",
    "section": "scANVI (Single-Cell ANnotation using Variational Inference)",
    "text": "scANVI (Single-Cell ANnotation using Variational Inference)\nimport scvi\n\n# Setup scANVI\nscvi.model.SCVI.setup_anndata(\n    adata,\n    layer=\"counts\",\n    batch_key=\"batch\",\n    labels_key=\"cell_type\"\n)\n\n# Train scVI first\nvae = scvi.model.SCVI(adata)\nvae.train()\n\n# Train scANVI\nscanvi_model = scvi.model.SCANVI.from_scvi_model(\n    vae,\n    unlabeled_category=\"Unknown\",\n    labels_key=\"cell_type\"\n)\nscanvi_model.train(max_epochs=20)\n\n# Predict\nadata.obs[\"predicted_cell_type\"] = scanvi_model.predict()\n\n# Get uncertainty\nadata.obs[\"prediction_score\"] = scanvi_model.predict(soft=True).max(axis=1)\n\n# Visualize\nsc.pl.umap(adata, color=['predicted_cell_type', 'prediction_score'])"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#azimuth-seurat-based",
    "href": "modules/12-celltype-prediction.html#azimuth-seurat-based",
    "title": "Module 12: Cell Type Prediction",
    "section": "Azimuth (Seurat-based)",
    "text": "Azimuth (Seurat-based)\n# Through R interface\nimport rpy2.robjects as ro\n\nro.r('''\nlibrary(Seurat)\nlibrary(Azimuth)\n\n# Load query data\nquery &lt;- Load10X_Spatial(\"path/to/data\")\n\n# Run Azimuth\nquery &lt;- RunAzimuth(query, reference = \"pbmcref\")\n\n# Predictions stored in metadata\n''')"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#singler",
    "href": "modules/12-celltype-prediction.html#singler",
    "title": "Module 12: Cell Type Prediction",
    "section": "SingleR",
    "text": "SingleR\n# Via rpy2\nro.r('''\nlibrary(SingleR)\nlibrary(celldex)\n\n# Load reference\nref &lt;- HumanPrimaryCellAtlasData()\n\n# Run SingleR\npredictions &lt;- SingleR(\n    test = query_data,\n    ref = ref,\n    labels = ref$label.main\n)\n''')"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#symphony",
    "href": "modules/12-celltype-prediction.html#symphony",
    "title": "Module 12: Cell Type Prediction",
    "section": "Symphony",
    "text": "Symphony\n# Reference mapping with Symphony\nfrom symphony import Symphony\n\n# Load reference\nreference = Symphony.load_reference('reference_name')\n\n# Map query\nquery_mapped = reference.map_query(\n    adata_query,\n    variables=['cell_type']\n)\n\n# View predictions\nprint(query_mapped.obs['cell_type_predicted'])"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#evaluating-predictions",
    "href": "modules/12-celltype-prediction.html#evaluating-predictions",
    "title": "Module 12: Cell Type Prediction",
    "section": "Evaluating Predictions",
    "text": "Evaluating Predictions\n\nConfidence Scores\n# Check prediction confidence\nsc.pl.violin(adata, 'conf_score', groupby='predicted_labels')\n\n# Filter low-confidence predictions\nthreshold = 0.5\nadata_confident = adata[adata.obs['conf_score'] &gt; threshold]\n\nprint(f\"High confidence: {adata_confident.n_obs}/{adata.n_obs}\")\n\n\nAgreement with Clustering\n# Compare with unsupervised clusters\nimport pandas as pd\n\nconfusion = pd.crosstab(\n    adata.obs['leiden'],\n    adata.obs['predicted_labels']\n)\n\n# Visualize\nimport seaborn as sns\nplt.figure(figsize=(10, 8))\nsns.heatmap(confusion, annot=True, fmt='d', cmap='Blues')\nplt.title('Cluster vs Predicted Cell Type')\nplt.show()\n\n\nMarker Gene Validation\n# Check if predicted types express expected markers\nmarkers = ['SYN1', 'GFAP', 'MBP', 'CX3CR1']\n\nsc.pl.dotplot(\n    adata,\n    markers,\n    groupby='predicted_labels',\n    dendrogram=True\n)"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#handling-ambiguous-cells",
    "href": "modules/12-celltype-prediction.html#handling-ambiguous-cells",
    "title": "Module 12: Cell Type Prediction",
    "section": "Handling Ambiguous Cells",
    "text": "Handling Ambiguous Cells\n\nMixed/Unknown Cells\n# Identify cells with low confidence\nadata.obs['annotation_quality'] = pd.cut(\n    adata.obs['conf_score'],\n    bins=[0, 0.3, 0.7, 1.0],\n    labels=['Low', 'Medium', 'High']\n)\n\n# Visualize\nsc.pl.umap(adata, color='annotation_quality')\n\n# Further analyze ambiguous cells\nambiguous = adata[adata.obs['annotation_quality'] == 'Low']\nsc.pl.umap(ambiguous, color='predicted_labels')\n\n\nDoublet-Like Cells\n# Cells expressing markers from multiple types\n# May indicate doublets or transitional states\n\n# Check for multi-type expression\nfrom collections import Counter\n\ndef check_multi_marker(adata, markers_dict, threshold=0.5):\n    \"\"\"Check if cells express markers from multiple types.\"\"\"\n    results = []\n\n    for cell_type, markers in markers_dict.items():\n        # Score for each type\n        expr = adata[:, markers].X.mean(axis=1)\n        results.append((cell_type, expr &gt; threshold))\n\n    # Count how many types each cell expresses\n    multi_type = sum(results, axis=0)\n    return multi_type &gt; 1"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#creating-reference-datasets",
    "href": "modules/12-celltype-prediction.html#creating-reference-datasets",
    "title": "Module 12: Cell Type Prediction",
    "section": "Creating Reference Datasets",
    "text": "Creating Reference Datasets\n\nRequirements\n\nHigh-quality, well-annotated data\nMultiple biological replicates\nRepresentative cell types\nMinimal batch effects\n\n\n\nBuilding Reference\n# 1. Curate high-quality reference\nreference = adata[adata.obs['annotation_confidence'] == 'High']\n\n# 2. Ensure cell type labels are consistent\nreference.obs['cell_type'] = reference.obs['cell_type'].astype('category')\n\n# 3. Process reference\nsc.pp.normalize_total(reference)\nsc.pp.log1p(reference)\n\n# 4. Train model\nfrom celltypist import train\n\nmodel = train(\n    reference,\n    labels='cell_type',\n    n_jobs=10,\n    max_iter=100\n)\n\n# 5. Save\nmodel.write('my_brain_reference.pkl')"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#hierarchical-annotation",
    "href": "modules/12-celltype-prediction.html#hierarchical-annotation",
    "title": "Module 12: Cell Type Prediction",
    "section": "Hierarchical Annotation",
    "text": "Hierarchical Annotation\n# Coarse-to-fine annotation strategy\n\n# 1. Broad categories first\npredictions_broad = celltypist.annotate(\n    adata,\n    model='Broad_Categories.pkl'\n)\n\n# 2. Fine-grained within each category\nfor broad_type in predictions_broad.predicted_labels.unique():\n    subset = adata[predictions_broad.predicted_labels == broad_type]\n\n    predictions_fine = celltypist.annotate(\n        subset,\n        model=f'{broad_type}_Detailed.pkl'\n    )\n\n    # Merge results\n    adata.obs.loc[subset.obs_names, 'detailed_type'] = \\\n        predictions_fine.predicted_labels"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#best-practices",
    "href": "modules/12-celltype-prediction.html#best-practices",
    "title": "Module 12: Cell Type Prediction",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipAnnotation Tips\n\n\n\n\nUse multiple methods and compare\nCheck prediction confidence scores\nValidate with known marker genes\nUse reference from similar tissue/species\nCombine automated + manual curation\nDocument annotation decisions\nConsider hierarchical approaches\nUpdate annotations as new data emerges"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#practical-exercise",
    "href": "modules/12-celltype-prediction.html#practical-exercise",
    "title": "Module 12: Cell Type Prediction",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad a query single-cell dataset\nApply CellTypist with pre-trained model\nEvaluate prediction confidence\nCompare with unsupervised clusters\nValidate with marker gene expression\nIdentify and investigate ambiguous cells\nRefine annotations if needed"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#key-takeaways",
    "href": "modules/12-celltype-prediction.html#key-takeaways",
    "title": "Module 12: Cell Type Prediction",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nAutomated annotation scales to large datasets\nMultiple tools available with different strengths\nAlways validate predictions\nConfidence scores indicate reliability\nNo method is perfect—manual curation may be needed\nChoose reference carefully"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#additional-resources",
    "href": "modules/12-celltype-prediction.html#additional-resources",
    "title": "Module 12: Cell Type Prediction",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nCellTypist Documentation\nscvi-tools Tutorials\nAzimuth Web App\nCell Type Annotation Review"
  },
  {
    "objectID": "modules/12-celltype-prediction.html#next-module",
    "href": "modules/12-celltype-prediction.html#next-module",
    "title": "Module 12: Cell Type Prediction",
    "section": "Next Module",
    "text": "Next Module\nExplore cellular dynamics with trajectory inference!\nContinue to Module 13: Trajectory Inference →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html",
    "href": "modules/14-spatial-transcriptomics.html",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "",
    "text": "Spatial transcriptomics measures gene expression while preserving spatial location, revealing how cells are organized in tissues and how location influences function.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand spatial transcriptomics technologies\nAnalyze 10x Visium data with Scanpy/Squidpy\nPerform spatial clustering\nIdentify spatially variable genes\nIntegrate spatial with scRNA-seq data"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#overview",
    "href": "modules/14-spatial-transcriptomics.html#overview",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "",
    "text": "Spatial transcriptomics measures gene expression while preserving spatial location, revealing how cells are organized in tissues and how location influences function.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand spatial transcriptomics technologies\nAnalyze 10x Visium data with Scanpy/Squidpy\nPerform spatial clustering\nIdentify spatially variable genes\nIntegrate spatial with scRNA-seq data"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#spatial-technologies",
    "href": "modules/14-spatial-transcriptomics.html#spatial-technologies",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Spatial Technologies",
    "text": "Spatial Technologies\n\nSequencing-Based\n\n10x Visium - 55µm spots - ~1-10 cells per spot - Whole transcriptome - Most widely used\nSlide-seq - 10µm beads - Higher resolution - Whole transcriptome\nHDST - 2µm resolution - Very high resolution - Subcellular detail\n\n\n\nImaging-Based\n\nMERFISH - Single-cell resolution - 100-10,000 genes - Multiplexed FISH\nseqFISH+ - Subcellular resolution - 10,000+ genes - Sequential hybridization\nXenium (10x) - Subcellular resolution - 300-500 genes - Automated platform"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#loading-visium-data",
    "href": "modules/14-spatial-transcriptomics.html#loading-visium-data",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Loading Visium Data",
    "text": "Loading Visium Data\nimport scanpy as sc\nimport squidpy as sq\n\n# Load Visium data\nadata = sc.read_visium(\n    path='visium_data',\n    count_file='filtered_feature_bc_matrix.h5',\n    load_images=True\n)\n\n# View data structure\nprint(adata)\nprint(adata.obs)\nprint(adata.uns['spatial'])"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#quality-control",
    "href": "modules/14-spatial-transcriptomics.html#quality-control",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Quality Control",
    "text": "Quality Control\n# Calculate QC metrics\nadata.var['mt'] = adata.var_names.str.startswith('MT-')\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], inplace=True)\n\n# Visualize QC on tissue\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\nsc.pl.spatial(adata, color='total_counts', ax=axes[0], show=False)\nsc.pl.spatial(adata, color='n_genes_by_counts', ax=axes[1], show=False)\nsc.pl.spatial(adata, color='pct_counts_mt', ax=axes[2], show=False)\n\nplt.tight_layout()"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#preprocessing",
    "href": "modules/14-spatial-transcriptomics.html#preprocessing",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Preprocessing",
    "text": "Preprocessing\n# Filter spots/genes\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=10)\n\n# Normalize and log transform\nsc.pp.normalize_total(adata, target_sum=1e4)\nsc.pp.log1p(adata)\n\n# Identify highly variable genes\nsc.pp.highly_variable_genes(adata, n_top_genes=2000)\n\n# Scale\nsc.pp.scale(adata)"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#dimensionality-reduction-and-clustering",
    "href": "modules/14-spatial-transcriptomics.html#dimensionality-reduction-and-clustering",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Dimensionality Reduction and Clustering",
    "text": "Dimensionality Reduction and Clustering\n# PCA\nsc.tl.pca(adata)\n\n# Neighbors and UMAP\nsc.pp.neighbors(adata, n_pcs=30)\nsc.tl.umap(adata)\n\n# Leiden clustering\nsc.tl.leiden(adata, resolution=0.5)\n\n# Visualize\nsc.pl.umap(adata, color=['leiden'])\nsc.pl.spatial(adata, color='leiden', size=1.5)"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#spatial-visualization",
    "href": "modules/14-spatial-transcriptomics.html#spatial-visualization",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Spatial Visualization",
    "text": "Spatial Visualization\n\nGene Expression Patterns\n# Single gene\nsc.pl.spatial(adata, color='BDNF', cmap='viridis', size=1.5)\n\n# Multiple genes\ngenes = ['BDNF', 'GFAP', 'MBP', 'CX3CR1']\nsc.pl.spatial(adata, color=genes, ncols=2, size=1.5)\n\n# With image overlay\nsc.pl.spatial(adata, color='BDNF', img_key='hires', alpha_img=0.5)\n\n\nClusters on Tissue\n# Clusters with spatial context\nsc.pl.spatial(adata, color='leiden', size=1.5, alpha=0.8)\n\n# Multiple images\nsq.pl.spatial_scatter(\n    adata,\n    color=['leiden', 'BDNF', 'GFAP'],\n    img=True,\n    alpha=0.7,\n    size=1.5\n)"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#spatially-variable-genes",
    "href": "modules/14-spatial-transcriptomics.html#spatially-variable-genes",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Spatially Variable Genes",
    "text": "Spatially Variable Genes\n\nMoran’s I\nimport squidpy as sq\n\n# Compute spatial neighbors\nsq.gr.spatial_neighbors(adata, coord_type='grid')\n\n# Calculate Moran's I\nsq.gr.spatial_autocorr(\n    adata,\n    mode='moran',\n    n_perms=100,\n    n_jobs=1\n)\n\n# View results\nmorans = adata.uns['moranI']\ntop_spatial = morans.nsmallest(20, 'pval_norm')\n\n# Visualize top spatially variable genes\nsc.pl.spatial(adata, color=top_spatial['names'].tolist()[:6], ncols=3)\n\n\nSpatial Clustering with Leiden\n# Spatial Leiden (considers spatial proximity)\nsq.gr.spatial_neighbors(adata, coord_type='grid')\n\nsc.tl.leiden(adata, obsp='spatial_connectivities', key_added='spatial_leiden')\n\n# Compare with regular clustering\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nsc.pl.spatial(adata, color='leiden', ax=ax1, show=False, title='Regular Leiden')\nsc.pl.spatial(adata, color='spatial_leiden', ax=ax2, show=False, title='Spatial Leiden')"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#neighborhood-analysis",
    "href": "modules/14-spatial-transcriptomics.html#neighborhood-analysis",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Neighborhood Analysis",
    "text": "Neighborhood Analysis\n\nCo-occurrence and Interaction\n# Compute co-occurrence\nsq.gr.co_occurrence(\n    adata,\n    cluster_key='leiden'\n)\n\n# Visualize\nsq.pl.co_occurrence(\n    adata,\n    cluster_key='leiden',\n    clusters='0',\n    figsize=(8, 8)\n)\n\n# Neighborhood enrichment\nsq.gr.nhood_enrichment(adata, cluster_key='leiden')\nsq.pl.nhood_enrichment(adata, cluster_key='leiden')\n\n\nSpatial Statistics\n# Ripley's statistics\nsq.gr.ripley(adata, cluster_key='leiden', mode='L')\n\n# Visualize\nsq.pl.ripley(adata, cluster_key='leiden')"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#ligand-receptor-interaction",
    "href": "modules/14-spatial-transcriptomics.html#ligand-receptor-interaction",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Ligand-Receptor Interaction",
    "text": "Ligand-Receptor Interaction\n# Compute ligrec interactions\nsq.gr.ligrec(\n    adata,\n    n_perms=100,\n    cluster_key='leiden',\n    interactions_params={\"resources\": \"consensus\"}\n)\n\n# Visualize\nsq.pl.ligrec(\n    adata,\n    cluster_key='leiden',\n    source_groups='0',\n    target_groups='1'\n)"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#integration-with-scrna-seq",
    "href": "modules/14-spatial-transcriptomics.html#integration-with-scrna-seq",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Integration with scRNA-seq",
    "text": "Integration with scRNA-seq\n\nCell Type Deconvolution\n# Using Tangram\nimport tangram as tg\n\n# Load reference scRNA-seq\nadata_sc = sc.read_h5ad('reference_scrna.h5ad')\n\n# Map scRNA-seq to spatial\ntg.pp_adatas(adata_sc, adata, genes=None)\n\nad_map = tg.map_cells_to_space(\n    adata_sc,\n    adata,\n    mode='cells',\n    device='cpu'\n)\n\n# Transfer cell type labels\ntg.project_cell_annotations(ad_map, adata, annotation='cell_type')\n\n# Visualize predicted cell types\nsc.pl.spatial(adata, color='cell_type', size=1.5)\n\n\nCell2location\nimport cell2location\n\n# Estimate reference signatures\nfrom cell2location.utils.filtering import filter_genes\n\nselected_genes = filter_genes(adata_sc, cell_count_cutoff=5)\n\n# Train reference model\nfrom cell2location.models import RegressionModel\n\nref_model = RegressionModel.setup_anndata(\n    adata_sc,\n    labels_key='cell_type'\n)\n\nref_model.train(max_epochs=250)\n\n# Map to spatial\nfrom cell2location.models import Cell2location\n\nmod = Cell2location.setup_anndata(adata, batch_key=\"sample\")\nmod.train(max_epochs=30000)\n\n# Get results\nadata = mod.export_posterior(\n    adata,\n    sample_kwargs={'num_samples': 1000}\n)\n\n# Visualize cell type abundances\ncell_types = adata.obs.columns[adata.obs.columns.str.startswith('cell_type_')]\n\nfor ct in cell_types[:4]:\n    sc.pl.spatial(adata, color=ct, cmap='viridis', size=1.5)"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#spatial-domains",
    "href": "modules/14-spatial-transcriptomics.html#spatial-domains",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Spatial Domains",
    "text": "Spatial Domains\n\nBayesSpace\n# Via rpy2\nimport rpy2.robjects as ro\n\nro.r('''\nlibrary(BayesSpace)\n\n# Run BayesSpace\nsce &lt;- spatialPreprocess(sce)\nsce &lt;- spatialCluster(sce, q=7, platform=\"Visium\", nrep=10000)\n\n# Enhanced resolution\nsce_enhanced &lt;- spatialEnhance(sce, q=7, platform=\"Visium\")\n''')"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#best-practices",
    "href": "modules/14-spatial-transcriptomics.html#best-practices",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipSpatial Analysis Tips\n\n\n\n\nAlways visualize on tissue\nConsider spatial autocorrelation\nValidate with histology/imaging\nUse integration for cell type assignment\nAccount for tissue heterogeneity\nCheck for batch effects\nUse spatial statistics appropriately"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#practical-exercise",
    "href": "modules/14-spatial-transcriptomics.html#practical-exercise",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nLoad Visium dataset\nPerform QC and visualization\nCluster spots\nIdentify spatially variable genes\nAnalyze spatial clustering patterns\nPerform neighborhood enrichment\nIntegrate with scRNA-seq reference\nVisualize cell type spatial distribution"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#common-challenges",
    "href": "modules/14-spatial-transcriptomics.html#common-challenges",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Common Challenges",
    "text": "Common Challenges\n\nLow resolution (Visium: multiple cells per spot)\nBatch effects between slides\nImage alignment issues\nComputational intensity\nIntegration with scRNA-seq\nInterpretation of spatial patterns"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#key-takeaways",
    "href": "modules/14-spatial-transcriptomics.html#key-takeaways",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nSpatial transcriptomics reveals tissue organization\nMultiple technologies with different resolutions\nSquidpy enables comprehensive spatial analysis\nSpatially variable genes show location-specific patterns\nIntegration with scRNA-seq enhances interpretation\nSpatial context is crucial for understanding biology"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#additional-resources",
    "href": "modules/14-spatial-transcriptomics.html#additional-resources",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nSquidpy Documentation\nTangram Documentation\n10x Visium Resources\nSpatial Transcriptomics Review"
  },
  {
    "objectID": "modules/14-spatial-transcriptomics.html#next-module",
    "href": "modules/14-spatial-transcriptomics.html#next-module",
    "title": "Module 14: Spatial Transcriptomics",
    "section": "Next Module",
    "text": "Next Module\nApply deep learning to single-cell data!\nContinue to Module 15: Deep Learning Part 1 →\n\n← Back to Schedule"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html",
    "href": "modules/16-deep-learning-part2.html",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "",
    "text": "Advanced deep learning architectures including graph neural networks (GNNs) and transformers are revolutionizing single-cell analysis, enabling new capabilities for cell-cell interaction modeling and foundation models.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand graph neural networks for cell-cell interactions\nApply attention mechanisms to single-cell data\nUse transformer-based foundation models\nImplement perturbation prediction with neural networks\nExplore generative models for single-cell data"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#overview",
    "href": "modules/16-deep-learning-part2.html#overview",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "",
    "text": "Advanced deep learning architectures including graph neural networks (GNNs) and transformers are revolutionizing single-cell analysis, enabling new capabilities for cell-cell interaction modeling and foundation models.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\n\nUnderstand graph neural networks for cell-cell interactions\nApply attention mechanisms to single-cell data\nUse transformer-based foundation models\nImplement perturbation prediction with neural networks\nExplore generative models for single-cell data"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#graph-neural-networks-gnns",
    "href": "modules/16-deep-learning-part2.html#graph-neural-networks-gnns",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Graph Neural Networks (GNNs)",
    "text": "Graph Neural Networks (GNNs)\n\nWhy GNNs for Single-Cell?\n\nCells form natural graphs (k-NN, spatial)\nModel cell-cell interactions\nLeverage neighborhood information\nApplicable to spatial transcriptomics\n\n\n\nCell Graph Construction\nimport scanpy as sc\nimport torch\nimport torch_geometric as tg\nfrom torch_geometric.data import Data\n\n# Build kNN graph\nsc.pp.neighbors(adata, n_neighbors=15)\n\n# Convert to PyTorch Geometric format\nedge_index = []\nfor i in range(adata.n_obs):\n    neighbors = adata.obsp['connectivities'][i].nonzero()[1]\n    for j in neighbors:\n        edge_index.append([i, j])\n\nedge_index = torch.LongTensor(edge_index).t()\n\n# Create graph data object\nx = torch.FloatTensor(adata.X.toarray())  # Node features\ny = torch.LongTensor(adata.obs['cell_type_encoded'].values)  # Labels\n\ngraph_data = Data(x=x, edge_index=edge_index, y=y)\n\n\nGNN Architecture\nfrom torch_geometric.nn import GCNConv, GATConv\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass GCN(nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super().__init__()\n        self.conv1 = GCNConv(input_dim, hidden_dim)\n        self.conv2 = GCNConv(hidden_dim, hidden_dim)\n        self.conv3 = GCNConv(hidden_dim, output_dim)\n\n    def forward(self, x, edge_index):\n        x = self.conv1(x, edge_index)\n        x = F.relu(x)\n        x = F.dropout(x, p=0.5, training=self.training)\n\n        x = self.conv2(x, edge_index)\n        x = F.relu(x)\n        x = F.dropout(x, p=0.5, training=self.training)\n\n        x = self.conv3(x, edge_index)\n        return F.log_softmax(x, dim=1)\n\n# Create model\nmodel = GCN(input_dim=2000, hidden_dim=128, output_dim=10)\n\n\nGraph Attention Networks (GAT)\nclass GAT(nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim, heads=8):\n        super().__init__()\n        self.conv1 = GATConv(input_dim, hidden_dim, heads=heads)\n        self.conv2 = GATConv(hidden_dim * heads, output_dim, heads=1)\n\n    def forward(self, x, edge_index):\n        x = self.conv1(x, edge_index)\n        x = F.elu(x)\n        x = F.dropout(x, p=0.6, training=self.training)\n\n        x = self.conv2(x, edge_index)\n        return F.log_softmax(x, dim=1)\n\n# Train GAT\ngat_model = GAT(input_dim=2000, hidden_dim=64, output_dim=10)\n\n\nTraining GNN\nimport torch.optim as optim\n\noptimizer = optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)\ncriterion = nn.CrossEntropyLoss()\n\n# Training loop\nmodel.train()\nfor epoch in range(200):\n    optimizer.zero_grad()\n    out = model(graph_data.x, graph_data.edge_index)\n    loss = criterion(out[train_mask], graph_data.y[train_mask])\n    loss.backward()\n    optimizer.step()\n\n    if epoch % 20 == 0:\n        model.eval()\n        with torch.no_grad():\n            pred = model(graph_data.x, graph_data.edge_index).argmax(dim=1)\n            acc = (pred[test_mask] == graph_data.y[test_mask]).float().mean()\n        print(f'Epoch {epoch}, Loss: {loss:.4f}, Acc: {acc:.4f}')\n        model.train()"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#attention-mechanisms",
    "href": "modules/16-deep-learning-part2.html#attention-mechanisms",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Attention Mechanisms",
    "text": "Attention Mechanisms\n\nSelf-Attention for Single-Cell\nclass AttentionLayer(nn.Module):\n    def __init__(self, input_dim, hidden_dim):\n        super().__init__()\n        self.query = nn.Linear(input_dim, hidden_dim)\n        self.key = nn.Linear(input_dim, hidden_dim)\n        self.value = nn.Linear(input_dim, hidden_dim)\n        self.scale = hidden_dim ** 0.5\n\n    def forward(self, x):\n        Q = self.query(x)\n        K = self.key(x)\n        V = self.value(x)\n\n        # Attention scores\n        scores = torch.matmul(Q, K.transpose(-2, -1)) / self.scale\n        attention = F.softmax(scores, dim=-1)\n\n        # Weighted values\n        output = torch.matmul(attention, V)\n        return output, attention\n\n# Use attention\nattention_layer = AttentionLayer(input_dim=2000, hidden_dim=128)\noutput, attention_weights = attention_layer(X_tensor)"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#transformer-architecture",
    "href": "modules/16-deep-learning-part2.html#transformer-architecture",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Transformer Architecture",
    "text": "Transformer Architecture\n\nSingle-Cell Transformer\nclass TransformerEncoder(nn.Module):\n    def __init__(self, input_dim, d_model, nhead, num_layers):\n        super().__init__()\n        self.embedding = nn.Linear(input_dim, d_model)\n        self.pos_encoding = nn.Parameter(torch.randn(1, 5000, d_model))\n\n        encoder_layer = nn.TransformerEncoderLayer(\n            d_model=d_model,\n            nhead=nhead,\n            dim_feedforward=d_model*4,\n            dropout=0.1,\n            batch_first=True\n        )\n        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers)\n        self.fc = nn.Linear(d_model, 10)  # Output classes\n\n    def forward(self, x):\n        # x shape: (batch_size, num_cells, input_dim)\n        x = self.embedding(x)\n        x = x + self.pos_encoding[:, :x.size(1), :]\n\n        x = self.transformer(x)\n        x = x.mean(dim=1)  # Global average pooling\n        x = self.fc(x)\n        return x\n\n# Create transformer\ntransformer = TransformerEncoder(\n    input_dim=2000,\n    d_model=512,\n    nhead=8,\n    num_layers=6\n)"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#scbert-foundation-model",
    "href": "modules/16-deep-learning-part2.html#scbert-foundation-model",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "scBERT: Foundation Model",
    "text": "scBERT: Foundation Model\n# Using pre-trained scBERT\n# (Conceptual - actual implementation may vary)\n\nfrom transformers import BertModel, BertConfig\n\n# Load pre-trained model\nconfig = BertConfig(\n    vocab_size=20000,  # Number of genes\n    hidden_size=768,\n    num_hidden_layers=12,\n    num_attention_heads=12\n)\n\nscbert = BertModel(config)\n\n# Fine-tune on your data\n# ... (fine-tuning code)\n\n# Extract embeddings\nwith torch.no_grad():\n    embeddings = scbert(input_ids).last_hidden_state\n\nadata.obsm['X_scbert'] = embeddings.mean(dim=1).numpy()"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#geneformer-gene-expression-foundation-model",
    "href": "modules/16-deep-learning-part2.html#geneformer-gene-expression-foundation-model",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Geneformer: Gene-Expression Foundation Model",
    "text": "Geneformer: Gene-Expression Foundation Model\n# Conceptual usage of Geneformer\n# Actual implementation requires specific data format\n\nfrom geneformer import TranscriptomeTokenizer, GeneformerPretrainer\n\n# Tokenize data\ntokenizer = TranscriptomeTokenizer()\ntokenized_data = tokenizer.tokenize_data(\n    adata,\n    output_dir=\"tokenized_data\",\n    gene_order=\"rank\"\n)\n\n# Load pre-trained model\nfrom transformers import BertForMaskedLM\n\nmodel = BertForMaskedLM.from_pretrained(\"geneformer-12L-30M\")\n\n# Fine-tune or extract embeddings\n# ... (specific to your task)"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#perturbation-prediction",
    "href": "modules/16-deep-learning-part2.html#perturbation-prediction",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Perturbation Prediction",
    "text": "Perturbation Prediction\n\nCPA (Compositional Perturbation Autoencoder)\n# Conceptual implementation\nclass PerturbationVAE(nn.Module):\n    def __init__(self, gene_dim, latent_dim, perturbation_dim):\n        super().__init__()\n\n        # Encoder\n        self.encoder = nn.Sequential(\n            nn.Linear(gene_dim, 1024),\n            nn.ReLU(),\n            nn.Linear(1024, 512),\n            nn.ReLU()\n        )\n\n        self.fc_mu = nn.Linear(512, latent_dim)\n        self.fc_logvar = nn.Linear(512, latent_dim)\n\n        # Perturbation embedding\n        self.pert_embedding = nn.Embedding(100, perturbation_dim)\n\n        # Decoder\n        self.decoder = nn.Sequential(\n            nn.Linear(latent_dim + perturbation_dim, 512),\n            nn.ReLU(),\n            nn.Linear(512, 1024),\n            nn.ReLU(),\n            nn.Linear(1024, gene_dim)\n        )\n\n    def forward(self, x, perturbation_id):\n        # Encode\n        h = self.encoder(x)\n        mu = self.fc_mu(h)\n        logvar = self.fc_logvar(h)\n\n        # Reparameterize\n        z = self.reparameterize(mu, logvar)\n\n        # Get perturbation embedding\n        pert_emb = self.pert_embedding(perturbation_id)\n\n        # Decode with perturbation\n        z_pert = torch.cat([z, pert_emb], dim=1)\n        recon = self.decoder(z_pert)\n\n        return recon, mu, logvar"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#scgen-predicting-cellular-responses",
    "href": "modules/16-deep-learning-part2.html#scgen-predicting-cellular-responses",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "scGen: Predicting Cellular Responses",
    "text": "scGen: Predicting Cellular Responses\n# Using scGen for perturbation prediction\nfrom scgen import SCGEN\n\n# Train on control cells\nscgen = SCGEN(adata_control, condition_key=\"condition\")\nscgen.train(max_epochs=100, batch_size=32, early_stopping=True)\n\n# Predict stimulated cells\npredicted_cells = scgen.predict(\n    control_key=\"control\",\n    stim_key=\"stimulated\",\n    cell_type_key=\"cell_type\"\n)\n\n# Visualize\nsc.pl.umap(predicted_cells, color=['condition', 'cell_type'])"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#generative-models",
    "href": "modules/16-deep-learning-part2.html#generative-models",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Generative Models",
    "text": "Generative Models\n\nConditional VAE for Cell Generation\nclass ConditionalVAE(nn.Module):\n    def __init__(self, input_dim, condition_dim, latent_dim):\n        super().__init__()\n\n        # Encoder\n        self.encoder = nn.Sequential(\n            nn.Linear(input_dim + condition_dim, 512),\n            nn.ReLU(),\n            nn.Linear(512, 256),\n            nn.ReLU()\n        )\n\n        self.fc_mu = nn.Linear(256, latent_dim)\n        self.fc_logvar = nn.Linear(256, latent_dim)\n\n        # Decoder\n        self.decoder = nn.Sequential(\n            nn.Linear(latent_dim + condition_dim, 256),\n            nn.ReLU(),\n            nn.Linear(256, 512),\n            nn.ReLU(),\n            nn.Linear(512, input_dim)\n        )\n\n    def encode(self, x, c):\n        h = self.encoder(torch.cat([x, c], dim=1))\n        return self.fc_mu(h), self.fc_logvar(h)\n\n    def decode(self, z, c):\n        return self.decoder(torch.cat([z, c], dim=1))\n\n    def forward(self, x, c):\n        mu, logvar = self.encode(x, c)\n        z = self.reparameterize(mu, logvar)\n        recon = self.decode(z, c)\n        return recon, mu, logvar\n\n# Generate cells with specific conditions\ndef generate_cells(model, condition, n_samples=100):\n    model.eval()\n    with torch.no_grad():\n        z = torch.randn(n_samples, latent_dim)\n        c = condition.repeat(n_samples, 1)\n        generated = model.decode(z, c)\n    return generated"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#best-practices",
    "href": "modules/16-deep-learning-part2.html#best-practices",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipAdvanced DL Tips\n\n\n\n\nUse appropriate architectures for your data structure\nLeverage pre-trained models when possible\nMonitor training carefully\nUse validation sets\nRegularize to prevent overfitting\nConsider interpretability\nValidate predictions experimentally\nShare trained models with community"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#model-interpretation",
    "href": "modules/16-deep-learning-part2.html#model-interpretation",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Model Interpretation",
    "text": "Model Interpretation\n\nAttention Visualization\n# Visualize attention weights\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Get attention from trained model\n_, attention_weights = model(X_tensor)\n\n# Plot attention map\nplt.figure(figsize=(10, 8))\nsns.heatmap(attention_weights[0].detach().numpy(), cmap='viridis')\nplt.title('Attention Weights')\nplt.xlabel('Key')\nplt.ylabel('Query')\nplt.show()\n\n\nFeature Importance\n# Integrated gradients for feature importance\nfrom captum.attr import IntegratedGradients\n\nig = IntegratedGradients(model)\nattributions = ig.attribute(X_tensor, target=target_class)\n\n# Visualize top features\ntop_features = attributions.abs().mean(dim=0).argsort(descending=True)[:20]\ngene_names = adata.var_names[top_features]\n\nplt.barh(range(20), attributions[:, top_features].mean(dim=0).detach())\nplt.yticks(range(20), gene_names)\nplt.xlabel('Attribution Score')\nplt.title('Top Important Genes')"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#practical-exercise",
    "href": "modules/16-deep-learning-part2.html#practical-exercise",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Practical Exercise",
    "text": "Practical Exercise\n\n\n\n\n\n\nImportantHands-On Activity\n\n\n\n\nBuild a GNN for cell type prediction\nImplement attention mechanism\nFine-tune a transformer model\nApply scVI for integration\nUse scGen for perturbation prediction\nVisualize attention weights\nInterpret model predictions"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#challenges-and-future-directions",
    "href": "modules/16-deep-learning-part2.html#challenges-and-future-directions",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Challenges and Future Directions",
    "text": "Challenges and Future Directions\n\nCurrent Challenges\n\nInterpretability of deep models\nComputational resources\nTraining data requirements\nGeneralization across datasets\nValidation of predictions\n\n\n\nFuture Directions\n\nEmerging trends:\n\nFoundation models for biology\nMulti-modal integration\nCausal modeling\nSpatial graph neural networks\nFew-shot learning for rare cell types\nExplainable AI for biology"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#key-takeaways",
    "href": "modules/16-deep-learning-part2.html#key-takeaways",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nGNNs model cell-cell relationships\nTransformers enable foundation models\nAttention mechanisms provide interpretability\nPerturbation prediction guides experiments\nPre-trained models accelerate research\nDeep learning is rapidly evolving"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#additional-resources",
    "href": "modules/16-deep-learning-part2.html#additional-resources",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nPyTorch Geometric Tutorial\nscvi-tools Advanced\nGeneformer Paper\nSingle-Cell Deep Learning Review"
  },
  {
    "objectID": "modules/16-deep-learning-part2.html#course-completion",
    "href": "modules/16-deep-learning-part2.html#course-completion",
    "title": "Module 16: Deep Learning in Single-Cell Genomics - Part 2",
    "section": "Course Completion",
    "text": "Course Completion\nCongratulations on completing the BRAIN course! You now have comprehensive skills in:\n\nNeurogenomics and single-cell technologies\nComputational analysis pipelines\nAdvanced machine learning and AI methods\nData interpretation and visualization\n\n\n\n\n\n\n\nNoteWhat’s Next?\n\n\n\n\nApply these skills to your research\nContribute to open-source projects\nStay updated with new methods\nJoin the single-cell community\nShare your findings!\n\n\n\n\n← Back to Module 15 | Return to Home | View Schedule\n\n\n\n\n\n\n\nImportantCertificate and Feedback\n\n\n\nCongratulations on completing all modules! Contact us for your certificate of completion and please provide feedback to help us improve the course."
  },
  {
    "objectID": "index.html#what-youll-master",
    "href": "index.html#what-youll-master",
    "title": "Welcome to BRAIN",
    "section": "What You’ll Master",
    "text": "What You’ll Master\nComprehensive training in cutting-edge computational methods for neuroscience research"
  },
  {
    "objectID": "index.html#course-modules",
    "href": "index.html#course-modules",
    "title": "Welcome to BRAIN",
    "section": "Course Modules",
    "text": "Course Modules\n16 comprehensive modules organized into three progressive learning phases"
  },
  {
    "objectID": "index.html#why-choose-brain",
    "href": "index.html#why-choose-brain",
    "title": "Welcome to BRAIN",
    "section": "Why Choose BRAIN?",
    "text": "Why Choose BRAIN?"
  },
  {
    "objectID": "index.html#ready-to-transform-your-research",
    "href": "index.html#ready-to-transform-your-research",
    "title": "Welcome to BRAIN",
    "section": "Ready to Transform Your Research?",
    "text": "Ready to Transform Your Research?\nJoin BRAIN and master computational neuroscience methods\nStart Your Journey Today"
  }
]